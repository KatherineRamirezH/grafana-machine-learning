{
  "__inputs": [
    {
      "name": "DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL",
      "label": "grafana-postgresql-datasource-ml-model",
      "description": "",
      "type": "datasource",
      "pluginId": "grafana-postgresql-datasource",
      "pluginName": "PostgreSQL"
    }
  ],
  "__elements": {},
  "__requires": [
    {
      "type": "grafana",
      "id": "grafana",
      "name": "Grafana",
      "version": "11.2.2"
    },
    {
      "type": "datasource",
      "id": "grafana-postgresql-datasource",
      "name": "PostgreSQL",
      "version": "1.0.0"
    },
    {
      "type": "panel",
      "id": "marcusolsson-dynamictext-panel",
      "name": "Business Text",
      "version": "5.4.0"
    },
    {
      "type": "panel",
      "id": "stat",
      "name": "Stat",
      "version": ""
    },
    {
      "type": "panel",
      "id": "volkovlabs-echarts-panel",
      "name": "Business Charts",
      "version": "6.5.0"
    }
  ],
  "annotations": {
    "list": [
      {
        "builtIn": 1,
        "datasource": {
          "type": "grafana",
          "uid": "-- Grafana --"
        },
        "enable": true,
        "hide": true,
        "iconColor": "rgba(0, 211, 255, 1)",
        "name": "Annotations & Alerts",
        "type": "dashboard"
      }
    ]
  },
  "editable": true,
  "fiscalYearStartMonth": 0,
  "graphTooltip": 0,
  "id": null,
  "links": [],
  "panels": [
    {
      "datasource": {
        "type": "grafana-postgresql-datasource",
        "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
      },
      "gridPos": {
        "h": 15,
        "w": 12,
        "x": 0,
        "y": 0
      },
      "id": 1,
      "options": {
        "baidu": {
          "callback": "bmapReady",
          "key": ""
        },
        "editor": {
          "format": "auto"
        },
        "editorMode": "code",
        "gaode": {
          "key": "",
          "plugin": "AMap.Scale,AMap.ToolBar"
        },
        "getOption": "if (context.panel.data && context.panel.data.series.length > 0) {\n  var fieldsPoints = context.panel.data.series[0].fields;\n  var fieldsCentroids = context.panel.data.series[1].fields;\n  var fieldsFeatures = context.panel.data.series[2].fields;\n  var fieldsClusterCount = context.panel.data.series[3].fields;\n\n  if (context.grafana.replaceVariables('${type}') == 'KMeans') {\n    fieldsPoints = context.panel.data.series[0].fields;\n    fieldsCentroids = context.panel.data.series[1].fields;\n  } else {\n    fieldsPoints = context.panel.data.series[4].fields;\n    fieldsCentroids = context.panel.data.series[5].fields;\n  }\n\n  let pointNames = (fieldsPoints.find(fields => fields.name == 'point_name')).values;\n  let pointValues = (fieldsPoints.find(fields => fields.name == 'feature_values')).values;\n  let pointClusters = (fieldsPoints.find(fields => fields.name == 'number_cluster')).values;\n  let centroidValues = (fieldsCentroids.find(fields => fields.name == 'feature_values')).values;\n  let centroidClusters = (fieldsCentroids.find(fields => fields.name == 'number_cluster')).values;\n  let featuresName = (fieldsFeatures.find(fields => fields.name == 'features_name')).values;\n  let clusterCount = (fieldsClusterCount.find(fields => fields.name == 'cluster_count')).values;\n\n  let parsedValuesPoints = pointValues.map(value => JSON.parse(value));\n  let parsedValuesCentroids = centroidValues.map(value => JSON.parse(value));\n\n  var CLUSTER_COUNT = clusterCount[0];\n  var DIENSIION_CLUSTER_INDEX = 2;\n  var selectedFeatureX = 0;\n  var selectedFeatureY = 1;\n\n  //Paleta de colores\n  var COLOR_ALL = ['#729ece', '#ff9e4a', '#67bf5c', '#ed665d', '#ad8bc9', '#a8786e', '#ed97ca', '#a2a2a2', '#cdcc5d', '#6dccda'];\n  if (context.grafana.replaceVariables('${color}') == 'Paleta 2') {\n    COLOR_ALL = ['#729ece', '#ff9e4a', '#67bf5c', '#ed665d', '#ad8bc9', '#a8786e', '#ed97ca', '#a2a2a2', '#cdcc5d', '#6dccda'];\n  } else if (context.grafana.replaceVariables('${color}') == 'Paleta 1') {\n    COLOR_ALL = ['#6929c4', '#9f1853', '#198038', '#1192e8', '#570408', '#b28600', '#002d9c', '#ee538b', '#a56eff', '#fa4d56'];\n  } else if (context.grafana.replaceVariables('${color}') == 'Paleta 3') {\n    COLOR_ALL = ['#9e0142', '#5e4fa2', '#66c2a5', '#3288bd', '#f46d43', '#e6f598', '#d53e4f', '#fd61ec', '#7cd42e', '#65d9e3'];\n  }\n\n  // Visual map\n  var pieces = [];\n  for (var i = 0; i < CLUSTER_COUNT; i++) {\n    pieces.push({\n      value: i,\n      label: 'clúster ' + i,\n      color: COLOR_ALL[i]\n    });\n  }\n\n  // Puntos \n  const pointSeriesData = createSeriesData(parsedValuesPoints, pointClusters, selectedFeatureX, selectedFeatureY);\n\n  // Centroides \n  const centroidSeriesData = createSeriesData(parsedValuesCentroids, centroidClusters, selectedFeatureX, selectedFeatureY);\n\n  // Lógica para la selección\n  if (context.grafana.replaceVariables('${index}')) {\n    let dom = context.panel.chart.getDom();\n    let nodeList = dom.childNodes;\n\n    if (nodeList.length > 2) {\n      nodeList[0].remove();\n    }\n\n    const container = document.createElement(\"div\");\n    container.style.display = \"flex\";\n    container.style.flexDirection = \"row\";\n    container.style.width = \"100%\";\n\n    const title = document.createElement(\"h3\");\n    title.innerHTML = \"Diagrama de dispersión\";\n    title.style.fontWeight = \"bold\";\n    title.style.fontSize = \"18px\";\n    title.style.fontFamily = \"'Arial', sans-serif\";\n    title.style.flexGrow = \"1\";\n    title.style.marginLeft = \"20px\";\n    title.style.marginTop = \"20px\";\n\n    const rightContainer = document.createElement(\"div\");\n    rightContainer.style.display = \"flex\";\n    rightContainer.style.flexDirection = \"column\";\n    rightContainer.style.alignItems = \"flex-end\";\n    rightContainer.style.marginLeft = \"10px\";\n\n    // Eje X\n    const xAxisContainer = document.createElement(\"div\");\n    xAxisContainer.style.display = \"flex\";\n    xAxisContainer.style.alignItems = \"center\";\n    xAxisContainer.style.marginBottom = \"2px\";\n\n    const xAxisLabel = document.createElement(\"span\");\n    xAxisLabel.innerHTML = \"Eje x:\";\n    xAxisLabel.style.marginRight = \"6px\";\n    xAxisLabel.style.fontFamily = \"'Arial', sans-serif\";\n    xAxisLabel.style.fontWeight = \"bold\";\n    xAxisLabel.style.fontSize = \"14px\";\n    xAxisLabel.style.marginTop = \"20px\";\n\n    const selectListX = document.createElement(\"select\");\n    selectListX.id = \"selectX\";\n    selectListX.style.fontFamily = \"'Arial', sans-serif\";\n    selectListX.style.border = \"1px solid gray\";\n    selectListX.style.borderRadius = \"8px\";\n    selectListX.style.padding = \"5px\";\n    selectListX.style.minWidth = \"120px\";\n    selectListX.style.marginTop = \"20px\";\n    selectListX.style.marginRight = \"10px\";\n\n    // Eje Y\n    const yAxisContainer = document.createElement(\"div\");\n    yAxisContainer.style.display = \"flex\";\n    yAxisContainer.style.alignItems = \"center\";\n    yAxisContainer.style.marginBottom = \"2px\";\n\n    const yAxisLabel = document.createElement(\"span\");\n    yAxisLabel.innerHTML = \"Eje y:\";\n    yAxisLabel.style.marginRight = \"6px\";\n    yAxisLabel.style.fontFamily = \"'Arial', sans-serif\";\n    yAxisLabel.style.fontWeight = \"bold\";\n    yAxisLabel.style.fontSize = \"14px\";\n\n    const selectListY = document.createElement(\"select\");\n    selectListY.id = \"selectY\";\n    selectListY.style.fontFamily = \"'Arial', sans-serif\";\n    selectListY.style.border = \"1px solid gray\";\n    selectListY.style.borderRadius = \"8px\";\n    selectListY.style.padding = \"5px\";\n    selectListY.style.minWidth = \"120px\";\n    selectListY.style.marginRight = \"10px\";\n\n    featuresName.forEach((value, index) => {\n      const optionX = document.createElement(\"option\");\n      optionX.value = index;\n      optionX.text = value;\n      selectListX.appendChild(optionX);\n\n      const optionY = document.createElement(\"option\");\n      optionY.value = index;\n      optionY.text = value;\n      selectListY.appendChild(optionY);\n    });\n\n    selectListY.value = selectedFeatureY;\n\n    selectListX.addEventListener(\"change\", () => {\n      selectedFeatureX = parseInt(selectListX.value);\n      updateChartData();\n    });\n\n    selectListY.addEventListener(\"change\", () => {\n      selectedFeatureY = parseInt(selectListY.value);\n      updateChartData();\n    });\n\n    // Añadiendo todo a rightContainer\n    xAxisContainer.appendChild(xAxisLabel);\n    xAxisContainer.appendChild(selectListX);\n    yAxisContainer.appendChild(yAxisLabel);\n    yAxisContainer.appendChild(selectListY);\n\n    rightContainer.appendChild(xAxisContainer);\n    rightContainer.appendChild(yAxisContainer);\n\n    // Añadiendo todo al container\n    container.appendChild(title);\n    container.appendChild(rightContainer);\n\n    dom.insertBefore(container, dom.firstChild);\n  }\n\n  // Función para actualizar el gráfico después de un cambio en la selección\n  function updateChartData() {\n    const pointSeriesData = createSeriesData(parsedValuesPoints, pointClusters, selectedFeatureX, selectedFeatureY);\n    const centroidSeriesData = createSeriesData(parsedValuesCentroids, centroidClusters, selectedFeatureX, selectedFeatureY);\n\n    context.panel.chart.setOption({\n      xAxis: {\n        name: featuresName[selectedFeatureX],\n        min: () => calculateMargin(pointValues, selectedFeatureX)\n      },\n      yAxis: {\n        name: featuresName[selectedFeatureY],\n        min: () => calculateMargin(pointValues, selectedFeatureY)\n      },\n      series: [\n        {\n          name: 'Puntos',\n          data: pointSeriesData\n        },\n        {\n          name: 'Centroides',\n          data: centroidSeriesData\n        }\n      ]\n    });\n  }\n\n  option = {\n    tooltip: {\n      position: 'top',\n      formatter: function (params) {\n        const seriesIndex = params.seriesIndex;\n        const dataIndex = params.dataIndex;\n\n        let featureValues = (seriesIndex === 0 ? parsedValuesPoints : parsedValuesCentroids)[dataIndex];\n        let clusterId = (seriesIndex === 0 ? pointClusters : centroidClusters)[dataIndex];\n        const pointName = (seriesIndex === 0 ? pointNames[dataIndex] : 'Centroide');\n\n        const featureName1 = featuresName[selectedFeatureX];\n        const featureName2 = featuresName[selectedFeatureY];\n\n        return `\n            <div><strong>${pointName}</strong></div>\n            <div><strong>Cluster: ${clusterId}</strong></div>\n            <div>${featureName1}: ${featureValues[selectedFeatureX]}</div>\n            <div>${featureName2}: ${featureValues[selectedFeatureY]}</div>\n          `;\n      }\n    },\n    visualMap: {\n      type: 'piecewise',\n      top: '22%',\n      min: 0,\n      max: CLUSTER_COUNT - 1,\n      left: 10,\n      dimension: DIENSIION_CLUSTER_INDEX,\n      pieces: pieces,\n      textStyle: {\n        fontSize: 14\n      },\n      inRange: {\n        color: COLOR_ALL\n      }\n    },\n    grid: {\n      bottom: \"23%\",\n      containLabel: true,\n      left: \"135\",\n      right: \"4%\",\n      top: \"3%\"\n    },\n    xAxis: {\n      type: 'value',\n      name: featuresName[selectedFeatureX],\n      nameLocation: 'middle',\n      nameGap: 20,\n      min: () => calculateMargin(pointValues, selectedFeatureX)\n    },\n    yAxis: {\n      type: 'value',\n      name: featuresName[selectedFeatureY],\n      nameLocation: 'middle',\n      nameGap: 30,\n      min: () => calculateMargin(pointValues, selectedFeatureY)\n    },\n    legend: {\n      data: ['Puntos', 'Centroides'],\n      top: '8%',\n      left: '1%',\n      orient: 'vertical',\n      textStyle: {\n        fontSize: 14\n      },\n      itemStyle: {\n        color: '#fff',\n        borderColor: '#000',\n        borderWidth: 1.5\n      }\n    },\n    series: [\n      {\n        name: 'Puntos',\n        type: 'scatter',\n        encode: { tooltip: [0, 1] },\n        symbolSize: 15,\n        symbol: getShape(context.grafana.replaceVariables('${shape}')),\n        itemStyle: {\n          color: '#888',\n          borderColor: '#555',\n        },\n        data: pointSeriesData,\n      },\n      {\n        name: 'Centroides',\n        type: 'scatter',\n        encode: { tooltip: [0, 1] },\n        symbol: `path://${getSvgPathCentroid()}`,\n        symbolSize: 25,\n        itemStyle: {\n          color: '#888',\n          borderColor: '#111',\n        },\n        data: centroidSeriesData,\n      }\n    ]\n  };\n  return option;\n}\n\n//Array dada 2 dimensiones y con el clúster \nfunction createSeriesData(values, clusters, dim1Index, dim2Index) {\n  return values.map((value, index) => {\n    const dim1 = value[dim1Index];\n    const dim2 = value[dim2Index];\n    const cluster = clusters[index];\n    const color = COLOR_ALL[cluster];\n\n    return {\n      value: [dim1, dim2, cluster],\n      itemStyle: {\n        color: color\n      }\n    };\n  });\n}\n\n//Calcular el margen del 5% basado en el rango de los datos\nfunction calculateMargin(values, axisIndex) {\n  const axisValues = values.map(value => JSON.parse(value)[axisIndex]);\n  const minValue = Math.min(...axisValues);\n  const maxValue = Math.max(...axisValues);\n  const range = maxValue - minValue;\n  const margin = range * 0.04;\n  const result = minValue - margin;\n\n  return parseFloat(result.toFixed(4));\n}\n\n//Símbolo de los centroides\nfunction getSvgPathCentroid() {\n  return \"M2750 12751 c-116 -26 -186 -52 -295 -110 -299 -157 -485 -326 -1104 \" +\n    \"-1004 -79 -86 -271 -277 -427 -422 -320 -301 -448 -431 -570 -584 -148 -183 \" +\n    \"-238 -344 -290 -517 -24 -78 -28 -106 -28 -234 -1 -176 13 -238 89 -395 133 \" +\n    \"-276 388 -564 1000 -1130 276 -255 599 -572 1175 -1154 437 -441 795 -808 795 \" +\n    \"-814 0 -12 -1837 -1835 -2267 -2250 -525 -506 -711 -761 -804 -1098 -13 -46 \" +\n    \"-18 -101 -18 -194 0 -152 19 -236 87 -375 60 -123 147 -232 362 -457 105 -109 \" +\n    \"323 -340 485 -513 580 -622 785 -826 1149 -1146 240 -212 346 -280 509 -326 \" +\n    \"111 -32 292 -31 417 1 355 92 700 348 1234 916 410 436 1057 1110 1286 1340 \" +\n    \"444 446 749 702 869 730 33 7 53 -13 1756 -1730 698 -703 847 -844 1040 -981 \" +\n    \"419 -297 777 -346 1153 -158 203 101 279 166 802 683 595 589 869 857 1067 \" +\n    \"1044 373 352 518 591 535 882 12 221 -66 463 -232 717 -184 281 -425 535 -985 \" +\n    \"1039 -219 197 -451 424 -900 879 -333 337 -656 658 -719 714 -155 137 -176 \" +\n    \"165 -175 227 0 38 8 59 35 99 19 27 463 474 987 992 1735 1716 1773 1755 1841 \" +\n    \"1853 79 114 132 225 162 340 20 75 23 114 23 230 -1 162 -19 243 -83 381 -83 \" +\n    \"177 -180 299 -487 614 -116 118 -334 357 -486 531 -456 523 -681 753 -933 954 \" +\n    \"-162 130 -277 205 -420 275 -404 199 -747 166 -1087 -104 -58 -47 -211 -190 \" +\n    \"-340 -319 -262 -263 -2071 -2052 -2303 -2278 -161 -156 -197 -182 -261 -183 \" +\n    \"-57 -1 -98 30 -200 149 -47 55 -208 224 -358 375 -1608 1625 -2172 2191 -2240 \" +\n    \"2249 -224 189 -409 268 -646 277 -89 3 -134 0 -200 -15z\";\n}\n\n\nfunction getShape(shape) {\n  let seLectedShapeValue = 'circle';\n\n  if (shape == 'Círculo') {\n    seLectedShapeValue = 'circle';\n  } else if (shape == 'Triángulo') {\n    seLectedShapeValue = 'triangle';\n  } else if (shape == 'Rectángulo') {\n    seLectedShapeValue = 'rect';\n  } else if (shape == 'Pin') {\n    seLectedShapeValue = 'pin';\n  }\n\n  return seLectedShapeValue;\n}\n\n",
        "google": {
          "callback": "gmapReady",
          "key": ""
        },
        "map": "none",
        "renderer": "canvas",
        "themeEditor": {
          "config": "{}",
          "name": "default"
        },
        "visualEditor": {
          "code": "\n",
          "dataset": [],
          "series": []
        }
      },
      "pluginVersion": "6.5.0",
      "targets": [
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
          },
          "editorMode": "code",
          "format": "table",
          "rawQuery": true,
          "rawSql": "SELECT \n  p.name AS point_name, \n  c.number AS number_cluster, \n  array_to_json(array_agg(pv.value ORDER BY pv.id_feature)) AS feature_values\nFROM \"grafana_ml_model_point\" p\nJOIN \"grafana_ml_model_point_value\" pv \n  ON pv.id_point = p.id\nJOIN \"grafana_ml_model_point_kmeans\" p_cluster\n  ON p_cluster.id_point = p.id\nJOIN \"grafana_ml_model_cluster\" c  \n  ON c.id = p_cluster.id_cluster  \nWHERE p.index=$index  AND pv.index=$index \n      AND p_cluster.index=$index AND c.index=$index\nGROUP BY p.id, c.number",
          "refId": "A",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        },
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
          },
          "editorMode": "code",
          "format": "table",
          "hide": false,
          "rawQuery": true,
          "rawSql": "SELECT \n  cl.number AS number_cluster,  \n  array_to_json(array_agg(c.value ORDER BY f.id)) AS feature_values\nFROM \"grafana_ml_model_centroid\" c\nJOIN \"grafana_ml_model_feature\" f\n  ON f.id = c.id_feature\nJOIN \"grafana_ml_model_cluster\" cl  \n  ON cl.id = c.id_cluster  \nWHERE c.index=$index AND f.index=$index AND cl.index=$index\nGROUP BY cl.number\nORDER BY cl.number\n\n",
          "refId": "B",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        },
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
          },
          "editorMode": "code",
          "format": "table",
          "hide": false,
          "rawQuery": true,
          "rawSql": "SELECT name AS features_name\nFROM grafana_ml_model_feature \nWHERE index=$index",
          "refId": "C",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        },
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
          },
          "editorMode": "code",
          "format": "table",
          "hide": false,
          "rawQuery": true,
          "rawSql": "SELECT \n  COUNT(DISTINCT cl.id) AS cluster_count\nFROM \n  \"grafana_ml_model_cluster\" cl\nJOIN \n  \"grafana_ml_model_centroid\" c\n  ON c.id_cluster = cl.id\nWHERE \n  c.index = $index AND cl.index = $index;",
          "refId": "D",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        },
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
          },
          "editorMode": "code",
          "format": "table",
          "hide": false,
          "rawQuery": true,
          "rawSql": "SELECT \n  p.name AS point_name, \n  c.number AS number_cluster, \n  array_to_json(array_agg(pv.value ORDER BY pv.id_feature)) AS feature_values\nFROM \"grafana_ml_model_point\" p\nJOIN \"grafana_ml_model_point_value\" pv \n  ON pv.id_point = p.id\nJOIN \"grafana_ml_model_point_kmedoids\" p_cluster\n  ON p_cluster.id_point = p.id\nJOIN \"grafana_ml_model_cluster\" c  \n  ON c.id = p_cluster.id_cluster  \nWHERE p.index=$index  AND pv.index=$index \n      AND p_cluster.index=$index AND c.index=$index \nGROUP BY p.id, c.number",
          "refId": "E",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        },
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
          },
          "editorMode": "code",
          "format": "table",
          "hide": false,
          "rawQuery": true,
          "rawSql": "SELECT \n  p.name AS point_name, \n  c.number AS number_cluster, \n  array_to_json(array_agg(pv.value ORDER BY pv.id_feature)) AS feature_values\nFROM \"grafana_ml_model_point\" p\nJOIN \"grafana_ml_model_point_value\" pv \n  ON pv.id_point = p.id\nJOIN \"grafana_ml_model_point_kmedoids\" p_cluster\n  ON p_cluster.id_point = p.id\nJOIN \"grafana_ml_model_cluster\" c  \n  ON c.id = p_cluster.id_cluster  \nWHERE p.index=$index  AND pv.index=$index \n      AND p_cluster.index=$index AND c.index=$index AND p_cluster.is_medoid=true\nGROUP BY p.id, c.number",
          "refId": "F",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        }
      ],
      "type": "volkovlabs-echarts-panel"
    },
    {
      "datasource": {
        "type": "grafana-postgresql-datasource",
        "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
      },
      "gridPos": {
        "h": 15,
        "w": 12,
        "x": 12,
        "y": 0
      },
      "id": 2,
      "options": {
        "baidu": {
          "callback": "bmapReady",
          "key": ""
        },
        "editor": {
          "format": "auto"
        },
        "editorMode": "code",
        "gaode": {
          "key": "",
          "plugin": "AMap.Scale,AMap.ToolBar"
        },
        "getOption": "if (context.panel.data && context.panel.data.series.length > 0) {\n  var fieldsFeature = context.panel.data.series[0].fields;\n  var fields = context.panel.data.series[1].fields;\n\n  if (context.grafana.replaceVariables('${type}') == 'KMeans') {\n    fields = context.panel.data.series[1].fields;\n  } else {\n    fields = context.panel.data.series[2].fields;\n  }\n\n  const clusterId = fields.find(field => field.name == 'cluster_id').values;\n  const clusterName = fields.find(field => field.name == 'cluster_number').values;\n  const featureName = fields.find(field => field.name == 'feature_name').values;\n  const featureValues = fields.find(field => field.name == 'feature_values').values;\n\n  const uniqueNamesFeature = fieldsFeature.find(fields => fields.name == 'features_name').values;\n\n  let data = getFeatureValuesByCluster(uniqueNamesFeature[0]);\n  let selectedFeature = uniqueNamesFeature[0];\n\n  // Lógica para la seleción\n  if (context.grafana.replaceVariables('${index}')) {\n    let dom = context.panel.chart.getDom();\n    let nodeList = dom.childNodes;\n\n    if (nodeList.length >= 2) {\n      nodeList[0].remove();\n    }\n\n    const container = document.createElement(\"div\");\n    container.style.display = \"flex\";\n    container.style.justifyContent = \"space-between\";\n    container.style.alignItems = \"center\";\n    container.style.marginTop = \"10px\";\n\n    const boxplotTitle = document.createElement(\"h3\");\n    boxplotTitle.innerHTML = \"Diagrama de caja. Características por clústeres.\";\n    boxplotTitle.style.marginLeft = \"20px\";\n    boxplotTitle.style.fontWeight = \"bold\";\n    boxplotTitle.style.fontSize = \"18px\";\n    boxplotTitle.style.fontFamily = \"'Arial', sans-serif\";\n\n    const rightContainer = document.createElement(\"div\");\n    rightContainer.style.display = \"flex\";\n    rightContainer.style.alignItems = \"center\";\n\n    const characteristicLabel = document.createElement(\"span\");\n    characteristicLabel.innerHTML = \"Característica:\";\n    characteristicLabel.style.marginRight = \"6px\";\n    characteristicLabel.style.fontFamily = \"'Arial', sans-serif\";\n    characteristicLabel.style.fontWeight = \"bold\";\n    characteristicLabel.style.fontSize = \"16px\";\n\n    const selectList = document.createElement(\"select\");\n    selectList.id = \"mySelect\";\n    selectList.style.fontFamily = \"'Arial', sans-serif\";\n    selectList.style.border = \"1px solid gray\";\n    selectList.style.borderRadius = \"8px\";\n    selectList.style.padding = \"5px\";\n    selectList.style.marginRight = \"10px\";\n\n    uniqueNamesFeature.forEach((value) => {\n      const option = document.createElement(\"option\");\n      option.value = value;\n      option.text = value;\n      selectList.appendChild(option);\n    });\n\n    selectList.addEventListener(\"change\", () => {\n      selectedFeature = selectList.value;\n      let result = getFeatureValuesByCluster(selectedFeature);\n\n      context.panel.chart.setOption({\n        dataset: [\n          {\n            source: result\n          },\n          {\n            transform: {\n              type: 'boxplot',\n              config: {\n                itemNameFormatter: function (params) {\n                  return 'clúster ' + (params.value + 1);\n                }\n              }\n            }\n          },\n          {\n            fromDatasetIndex: 1,\n            fromTransformResult: 1\n          },\n        ],\n        yAxis: {\n          type: 'value',\n          min: calculateMargin(result),\n          splitArea: {\n            show: true\n          }\n        }\n      });\n    });\n\n    rightContainer.appendChild(characteristicLabel);\n    rightContainer.appendChild(selectList);\n\n    container.appendChild(boxplotTitle);\n    container.appendChild(rightContainer);\n\n    dom.insertBefore(container, dom.firstChild);\n\n  }\n\n  option = {\n    title: [\n      {\n        text: 'upper: Q3 + 1.5 * IQR \\nlower: Q1 - 1.5 * IQR',\n        borderColor: '#999',\n        borderWidth: 1,\n        textStyle: {\n          fontWeight: 'normal',\n          fontSize: 14,\n          lineHeight: 20\n        },\n        left: '10%',\n        top: '80%'\n      }\n    ],\n    dataset: [\n      {\n        source: data\n      },\n      {\n        transform: {\n          type: 'boxplot',\n          config: {\n            itemNameFormatter: function (params) {\n              return 'clúster ' + (params.value + 1);\n            }\n          }\n        }\n      },\n      {\n        fromDatasetIndex: 1,\n        fromTransformResult: 1\n      }\n    ],\n    tooltip: {\n      trigger: 'item',\n      axisPointer: {\n        type: 'shadow'\n      }\n    },\n    grid: {\n      left: '10%',\n      right: '10%',\n      bottom: '28%',\n      top: '7%'\n    },\n    xAxis: {\n      type: 'category',\n      boundaryGap: true,\n      nameGap: 30,\n      splitArea: {\n        show: false\n      },\n      splitLine: {\n        show: false\n      }\n    },\n    yAxis: {\n      type: 'value',\n      min: calculateMargin(data),\n      splitArea: {\n        show: true\n      }\n    },\n    series: [\n      {\n        name: 'boxplot',\n        type: 'boxplot',\n        datasetIndex: 1,\n      },\n      {\n        name: 'outlier',\n        type: 'scatter',\n        datasetIndex: 2\n      }\n    ],\n\n  };\n\n  var COLOR_ALL = ['#729ece', '#ff9e4a', '#67bf5c', '#ed665d', '#ad8bc9', '#a8786e', '#ed97ca', '#a2a2a2', '#cdcc5d', '#6dccda'];\n  if (context.grafana.replaceVariables('${color}') == 'Paleta 1') {\n    COLOR_ALL = ['#729ece', '#ff9e4a', '#67bf5c', '#ed665d', '#ad8bc9', '#a8786e', '#ed97ca', '#a2a2a2', '#cdcc5d', '#6dccda'];\n  } else if (context.grafana.replaceVariables('${color}') == 'Paleta 2') {\n    COLOR_ALL = ['#6929c4', '#9f1853', '#198038', '#1192e8', '#570408', '#b28600', '#002d9c', '#ee538b', '#a56eff', '#fa4d56'];\n  } else if (context.grafana.replaceVariables('${color}') == 'Paleta 3') {\n    COLOR_ALL = ['#9e0142', '#5e4fa2', '#66c2a5', '#3288bd', '#f46d43', '#e6f598', '#d53e4f', '#fd61ec', '#7cd42e', '#65d9e3'];\n  }\n\n  return option;\n}\n\nfunction getFeatureValuesByCluster(featureName) {\n  const fields = context.panel.data.series[1].fields;\n  let clusterId = fields.find(field => field.name == 'cluster_id').values;\n  let featureNames = fields.find(field => field.name == 'feature_name').values;\n  let featureValues = fields.find(field => field.name == 'feature_values').values;\n\n  let clusterData = {};\n\n  for (let i = 0; i < featureNames.length; i++) {\n    if (featureNames[i] === featureName) {\n      let cluster = clusterId[i];\n      let values = featureValues[i];\n\n      values = JSON.parse(values);\n\n      if (!clusterData[cluster]) {\n        clusterData[cluster] = [];\n      }\n\n      clusterData[cluster].push(...values);\n    }\n  }\n\n  return Object.values(clusterData);\n}\n\n// Calcular el margen del 5% basado en el rango de los datos\nfunction calculateMargin(clusterData) {\n  const allValues = clusterData.flat();\n  const minValue = Math.min(...allValues);\n  const maxValue = Math.max(...allValues);\n  const range = maxValue - minValue;\n  const margin = range * 0.05;\n  const result = minValue - margin;\n  return parseFloat(result.toFixed(4));\n}\n\n",
        "google": {
          "callback": "gmapReady",
          "key": ""
        },
        "map": "none",
        "renderer": "canvas",
        "themeEditor": {
          "config": "{}",
          "name": "default"
        },
        "visualEditor": {
          "code": "",
          "dataset": [],
          "series": []
        }
      },
      "pluginVersion": "6.5.0",
      "targets": [
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
          },
          "editorMode": "code",
          "format": "table",
          "rawQuery": true,
          "rawSql": "SELECT name AS features_name\nFROM grafana_ml_model_feature \nWHERE index=$index",
          "refId": "A",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        },
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
          },
          "editorMode": "code",
          "format": "table",
          "hide": false,
          "rawQuery": true,
          "rawSql": "SELECT \n    cl.id AS cluster_id,  \n    cl.number AS cluster_number, \n    f.name AS feature_name,  \n    array_to_json(array_agg(pv.value)) AS feature_values  \nFROM \n    \"grafana_ml_model_cluster\" cl\nJOIN \n    \"grafana_ml_model_point_kmeans\" p_cluster ON p_cluster.id_cluster = cl.id  \nJOIN \n    \"grafana_ml_model_point\" p ON p.id = p_cluster.id_point  \nJOIN \n    \"grafana_ml_model_point_value\" pv ON pv.id_point = p.id  \nJOIN \n    \"grafana_ml_model_feature\" f ON f.id = pv.id_feature  \nWHERE cl.index=$index  AND p_cluster.index=$index AND p.index=$index AND pv.index=$index\nGROUP BY \n    cl.id, cl.number, f.id, f.name  \nORDER BY \n    cl.id, f.id;  \n    ",
          "refId": "B",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        },
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
          },
          "editorMode": "code",
          "format": "table",
          "hide": false,
          "rawQuery": true,
          "rawSql": "SELECT \n    cl.id AS cluster_id,  \n    cl.number AS cluster_number, \n    f.name AS feature_name,  \n    array_to_json(array_agg(pv.value)) AS feature_values  \nFROM \n    \"grafana_ml_model_cluster\" cl\nJOIN \n    \"grafana_ml_model_point_kmedoids\" p_cluster ON p_cluster.id_cluster = cl.id  \nJOIN \n    \"grafana_ml_model_point\" p ON p.id = p_cluster.id_point  \nJOIN \n    \"grafana_ml_model_point_value\" pv ON pv.id_point = p.id  \nJOIN \n    \"grafana_ml_model_feature\" f ON f.id = pv.id_feature  \nWHERE cl.index=$index  AND p_cluster.index=$index AND p.index=$index AND pv.index=$index\nGROUP BY \n    cl.id, cl.number, f.id, f.name  \nORDER BY \n    cl.id, f.id;  \n    ",
          "refId": "C",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        }
      ],
      "type": "volkovlabs-echarts-panel"
    },
    {
      "datasource": {
        "type": "grafana-postgresql-datasource",
        "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
      },
      "gridPos": {
        "h": 13,
        "w": 12,
        "x": 0,
        "y": 15
      },
      "id": 3,
      "options": {
        "baidu": {
          "callback": "bmapReady",
          "key": ""
        },
        "editor": {
          "format": "auto"
        },
        "editorMode": "code",
        "gaode": {
          "key": "",
          "plugin": "AMap.Scale,AMap.ToolBar"
        },
        "getOption": "if (context.panel.data && context.panel.data.series.length > 0) {\n  var fieldsCentroids = context.panel.data.series[0].fields;\n  var fieldsPoints = context.panel.data.series[2].fields;\n  var fieldsFeatures = context.panel.data.series[1].fields;\n  var fieldsClusterCount = context.panel.data.series[3].fields;\n\n  if (context.grafana.replaceVariables('${type}') == 'KMeans') {\n    fieldsPoints = context.panel.data.series[2].fields;\n    fieldsCentroids = context.panel.data.series[0].fields;\n  } else {\n    fieldsPoints = context.panel.data.series[4].fields;\n    fieldsCentroids = context.panel.data.series[5].fields;\n  }\n\n  let pointNames = (fieldsPoints.find(fields => fields.name == 'point_name')).values;\n  let pointValues = (fieldsPoints.find(fields => fields.name == 'feature_values')).values;\n  let pointClusters = (fieldsPoints.find(fields => fields.name == 'number_cluster')).values;\n  let centroidValues = (fieldsCentroids.find(fields => fields.name == 'feature_values')).values;\n  let centroidClusters = (fieldsCentroids.find(fields => fields.name == 'number_cluster')).values;\n  let featuresName = (fieldsFeatures.find(fields => fields.name == 'features_name')).values;\n  let clusterCount = (fieldsClusterCount.find(fields => fields.name == 'cluster_count')).values;\n\n  let parsedValuesCentroids = centroidValues.map(value => JSON.parse(value));\n  let parsedValuesPoints = pointValues.map(value => JSON.parse(value));\n\n  const percentageIncrease = 0.1;  // 10%\n  var CLUSTER_COUNT = clusterCount[0];\n  var DIENSIION_CLUSTER_INDEX = featuresName.length;\n\n  var COLOR_ALL = ['#729ece', '#ff9e4a', '#67bf5c', '#ed665d', '#ad8bc9', '#a8786e', '#ed97ca', '#a2a2a2', '#cdcc5d', '#6dccda'];\n\n  if (context.grafana.replaceVariables('${color}') == 'Paleta 2') {\n    COLOR_ALL = ['#729ece', '#ff9e4a', '#67bf5c', '#ed665d', '#ad8bc9', '#a8786e', '#ed97ca', '#a2a2a2', '#cdcc5d', '#6dccda'];\n  } else if (context.grafana.replaceVariables('${color}') == 'Paleta 1') {\n    COLOR_ALL = ['#6929c4', '#9f1853', '#198038', '#1192e8', '#570408', '#b28600', '#002d9c', '#ee538b', '#a56eff', '#fa4d56'];\n  } else if (context.grafana.replaceVariables('${color}') == 'Paleta 3') {\n    COLOR_ALL = ['#9e0142', '#5e4fa2', '#66c2a5', '#3288bd', '#f46d43', '#e6f598', '#d53e4f', '#fd61ec', '#7cd42e', '#65d9e3'];\n  }\n\n  //Leyenda\n  var pieces = [];\n  for (var i = 0; i < CLUSTER_COUNT; i++) {\n    pieces.push({\n      value: i,\n      label: 'clúster ' + i,\n      color: COLOR_ALL[i]\n    });\n  }\n\n  let radarIndicatorsPoints = featuresName.map((feature, featureIndex) => {\n    let maxFeatureValue = Math.max(...parsedValuesPoints.map(value => value[featureIndex]));\n    let adjustedMax = maxFeatureValue * (1 + percentageIncrease);\n\n    return {\n      name: feature,\n      max: adjustedMax\n    };\n  });\n\n  const pointSeriesData = parsedValuesPoints.map((value, index) => ({\n    value: [...value, pointClusters[index]],\n    color: COLOR_ALL[pointClusters[index]]\n  }));\n\n  const centroidSeriesData = parsedValuesCentroids.map((value, index) => ({\n    value: [...value, centroidClusters[index]],\n    color: COLOR_ALL[centroidClusters[index]]\n  }));\n\n  option = {\n    title: {\n      text: 'Características de los clústeres',\n      top: \"2%\",\n      left: \"2%\"\n    },\n    visualMap: {\n      type: 'piecewise',\n      top: 'middle',\n      min: 0,\n      max: CLUSTER_COUNT - 1,\n      left: 10,\n      splitNumber: CLUSTER_COUNT,\n      dimension: DIENSIION_CLUSTER_INDEX,\n      pieces: pieces,\n      inRange: {\n        color: COLOR_ALL\n      },\n    },\n    radar: {\n      indicator: radarIndicatorsPoints\n    },\n    series: [\n      {\n        name: 'Puntos',\n        type: 'radar',\n        lineStyle: {\n          width: context.grafana.replaceVariables('${sizeLine}')\n        },\n        data: pointSeriesData\n      },\n      {\n        name: 'Centroides',\n        type: 'radar',\n        lineStyle: {\n          width: context.grafana.replaceVariables('${sizeLine}'),\n          type: 'dashed'\n        },\n        data: centroidSeriesData\n      },\n    ],\n    legend: {\n      data: ['Puntos', 'Centroides'],\n      top: '30%',\n      left: '1%',\n      orient: 'vertical',\n      textStyle: {\n        fontSize: 12\n      },\n      itemStyle: {\n        color: '#fff',\n        borderColor: '#999',\n        borderWidth: 1\n      },\n      itemWidth: 12,\n      itemHeight: 12\n    },\n  };\n\n  return option;\n}",
        "google": {
          "callback": "gmapReady",
          "key": ""
        },
        "map": "none",
        "renderer": "canvas",
        "themeEditor": {
          "config": "{}",
          "name": "default"
        },
        "visualEditor": {
          "code": "\n",
          "dataset": [],
          "series": []
        }
      },
      "pluginVersion": "6.5.0",
      "targets": [
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
          },
          "editorMode": "code",
          "format": "table",
          "rawQuery": true,
          "rawSql": "SELECT \n  cl.number AS number_cluster,  \n  array_to_json(array_agg(c.value ORDER BY f.id)) AS feature_values\nFROM \"grafana_ml_model_centroid\" c\nJOIN \"grafana_ml_model_feature\" f\n  ON f.id = c.id_feature\nJOIN \"grafana_ml_model_cluster\" cl  \n  ON cl.id = c.id_cluster \nWHERE c.index=$index AND f.index=$index AND cl.index=$index\nGROUP BY cl.number\nORDER BY cl.number\n",
          "refId": "A",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        },
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
          },
          "editorMode": "code",
          "format": "table",
          "hide": false,
          "rawQuery": true,
          "rawSql": "SELECT name AS features_name\nFROM grafana_ml_model_feature \nWHERE grafana_ml_model_feature.index=$index",
          "refId": "B",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        },
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
          },
          "editorMode": "code",
          "format": "table",
          "hide": false,
          "rawQuery": true,
          "rawSql": "SELECT \n  p.name AS point_name, \n  c.number AS number_cluster, \n  array_to_json(array_agg(pv.value ORDER BY pv.id_feature)) AS feature_values\nFROM \"grafana_ml_model_point\" p\nJOIN \"grafana_ml_model_point_value\" pv \n  ON pv.id_point = p.id\nJOIN \"grafana_ml_model_point_kmeans\" p_cluster\n  ON p_cluster.id_point = p.id\nJOIN \"grafana_ml_model_cluster\" c  \n  ON c.id = p_cluster.id_cluster  \nWHERE p.index=$index  AND pv.index=$index \n      AND p_cluster.index=$index AND c.index=$index\nGROUP BY p.id, c.number",
          "refId": "C",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        },
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
          },
          "editorMode": "code",
          "format": "table",
          "hide": false,
          "rawQuery": true,
          "rawSql": "SELECT \n  COUNT(DISTINCT cl.id) AS cluster_count\nFROM \n  \"grafana_ml_model_cluster\" cl\nJOIN \n  \"grafana_ml_model_centroid\" c\n  ON c.id_cluster = cl.id\nWHERE \n  c.index = $index AND cl.index = $index;\n",
          "refId": "D",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        },
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
          },
          "editorMode": "code",
          "format": "table",
          "hide": false,
          "rawQuery": true,
          "rawSql": "SELECT \n  p.name AS point_name, \n  c.number AS number_cluster, \n  array_to_json(array_agg(pv.value ORDER BY pv.id_feature)) AS feature_values\nFROM \"grafana_ml_model_point\" p\nJOIN \"grafana_ml_model_point_value\" pv \n  ON pv.id_point = p.id\nJOIN \"grafana_ml_model_point_kmedoids\" p_cluster\n  ON p_cluster.id_point = p.id\nJOIN \"grafana_ml_model_cluster\" c  \n  ON c.id = p_cluster.id_cluster  \nWHERE p.index=$index  AND pv.index=$index \n      AND p_cluster.index=$index AND c.index=$index \nGROUP BY p.id, c.number",
          "refId": "E",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        },
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
          },
          "editorMode": "code",
          "format": "table",
          "hide": false,
          "rawQuery": true,
          "rawSql": "SELECT \n  p.name AS point_name, \n  c.number AS number_cluster, \n  array_to_json(array_agg(pv.value ORDER BY pv.id_feature)) AS feature_values\nFROM \"grafana_ml_model_point\" p\nJOIN \"grafana_ml_model_point_value\" pv \n  ON pv.id_point = p.id\nJOIN \"grafana_ml_model_point_kmedoids\" p_cluster\n  ON p_cluster.id_point = p.id\nJOIN \"grafana_ml_model_cluster\" c  \n  ON c.id = p_cluster.id_cluster  \nWHERE p.index=$index  AND pv.index=$index \n      AND p_cluster.index=$index AND c.index=$index AND p_cluster.is_medoid=true\nGROUP BY p.id, c.number",
          "refId": "F",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        }
      ],
      "type": "volkovlabs-echarts-panel"
    },
    {
      "datasource": {
        "type": "grafana-postgresql-datasource",
        "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
      },
      "gridPos": {
        "h": 13,
        "w": 12,
        "x": 12,
        "y": 15
      },
      "id": 8,
      "options": {
        "baidu": {
          "callback": "bmapReady",
          "key": ""
        },
        "editor": {
          "format": "auto"
        },
        "editorMode": "code",
        "gaode": {
          "key": "",
          "plugin": "AMap.Scale,AMap.ToolBar"
        },
        "getOption": "if (context.panel.data && context.panel.data.series.length > 0) {\n  var fieldsPoints = context.panel.data.series[0].fields;\n  var fieldsFeatures = context.panel.data.series[1].fields;\n  var fieldsClusterCount = context.panel.data.series[2].fields;\n  var fieldsCentroid = context.panel.data.series[3].fields;\n\n  if (context.grafana.replaceVariables('${type}') == 'KMeans') {\n    fieldsPoints = context.panel.data.series[0].fields;\n    fieldsCentroids = context.panel.data.series[3].fields;\n  } else {\n    fieldsPoints = context.panel.data.series[4].fields;\n    fieldsCentroids = context.panel.data.series[5].fields;\n  }\n\n  let pointNames = (fieldsPoints.find(fields => fields.name == 'point_name')).values;\n  let pointValues = (fieldsPoints.find(fields => fields.name == 'feature_values')).values;\n  let pointClusters = (fieldsPoints.find(fields => fields.name == 'number_cluster')).values;\n  let featuresName = (fieldsFeatures.find(fields => fields.name == 'features_name')).values;\n  let clusterCount = (fieldsClusterCount.find(fields => fields.name == 'cluster_count')).values;\n  let centroidValues = (fieldsCentroid.find(fields => fields.name == 'feature_values')).values;\n  let centroidClusters = (fieldsCentroid.find(fields => fields.name == 'number_cluster')).values;\n  let parsedValuesPoints = pointValues.map(value => JSON.parse(value));\n  let parsedValuesCentroids = centroidValues.map(value => JSON.parse(value));\n\n\n  var COLOR_ALL = ['#729ece', '#ff9e4a', '#67bf5c', '#ed665d', '#ad8bc9', '#a8786e', '#ed97ca', '#a2a2a2', '#cdcc5d', '#6dccda'];\n\n  if (context.grafana.replaceVariables('${color}') == 'Paleta 2') {\n    COLOR_ALL = ['#729ece', '#ff9e4a', '#67bf5c', '#ed665d', '#ad8bc9', '#a8786e', '#ed97ca', '#a2a2a2', '#cdcc5d', '#6dccda'];\n  } else if (context.grafana.replaceVariables('${color}') == 'Paleta 1') {\n    COLOR_ALL = ['#6929c4', '#9f1853', '#198038', '#1192e8', '#570408', '#b28600', '#002d9c', '#ee538b', '#a56eff', '#fa4d56'];\n  } else if (context.grafana.replaceVariables('${color}') == 'Paleta 3') {\n    COLOR_ALL = ['#9e0142', '#5e4fa2', '#66c2a5', '#3288bd', '#f46d43', '#e6f598', '#d53e4f', '#fd61ec', '#7cd42e', '#65d9e3'];\n  }\n  var CLUSTER_COUNT = clusterCount[0];\n  var DIENSIION_CLUSTER_INDEX = featuresName.length;\n\n  //Leyenda\n  var pieces = [];\n  for (var i = 0; i < CLUSTER_COUNT; i++) {\n    pieces.push({\n      value: i,\n      label: 'clúster ' + i,\n      color: COLOR_ALL[i]\n    });\n  }\n\n  const pointSeriesData = parsedValuesPoints.map((value, index) => ({\n    value: [...value, pointClusters[index]],\n    itemStyle: {\n      color: COLOR_ALL[pointClusters[index]]\n    }\n  }));\n\n  const centroidSeriesData = parsedValuesCentroids.map((value, index) => ({\n    value: [...value, centroidClusters[index]],\n    itemStyle: {\n      color: COLOR_ALL[centroidClusters[index]]\n    }\n  }));\n\n  let dimensions = featuresName.map((name, index) => {\n    return { dim: index, name: name };\n  });\n\n  option = {\n    title: {\n      text: 'Características de los clústeres',\n      top: \"2%\",\n      left: \"2%\"\n    },\n    parallelAxis: dimensions,\n    series: [\n      {\n        name: 'Puntos',\n        type: 'parallel',\n        lineStyle: {\n          width: 2 * context.grafana.replaceVariables('${sizeLine}')\n        },\n        data: pointSeriesData\n      },\n      {\n        name: 'Centroides',\n        type: 'parallel',\n        lineStyle: {\n          width: 2 * context.grafana.replaceVariables('${sizeLine}'),\n          type: 'dashed'\n        },\n        data: centroidSeriesData\n      },\n    ]\n    , parallel: {\n      bottom: \"4%\",\n      left: \"100\",\n      right: \"6%\",\n      top: \"18%\"\n    },\n    visualMap: {\n      type: 'piecewise',\n      top: 'middle',\n      min: 0,\n      max: CLUSTER_COUNT - 1,\n      left: 10,\n      splitNumber: CLUSTER_COUNT,\n      dimension: DIENSIION_CLUSTER_INDEX,\n      pieces: pieces,\n      inRange: {\n        color: COLOR_ALL\n      }\n    },\n    legend: {\n      data: ['Puntos', 'Centroides'],\n      top: '30%',\n      left: '1%',\n      orient: 'vertical',\n      textStyle: {\n        fontSize: 12\n      },\n      itemStyle: {\n        color: '#fff',\n        borderColor: '#999',\n        borderWidth: 1\n      },\n      itemWidth: 12,\n      itemHeight: 12\n    },\n  };\n\n  return option;\n}",
        "google": {
          "callback": "gmapReady",
          "key": ""
        },
        "map": "none",
        "renderer": "canvas",
        "themeEditor": {
          "config": "{}",
          "name": "default"
        },
        "visualEditor": {
          "code": "\n",
          "dataset": [],
          "series": []
        }
      },
      "pluginVersion": "6.5.0",
      "targets": [
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
          },
          "editorMode": "code",
          "format": "table",
          "rawQuery": true,
          "rawSql": "SELECT \n  p.name AS point_name, \n  c.number AS number_cluster,  \n  array_to_json(array_agg(pv.value ORDER BY pv.id_feature)) AS feature_values\nFROM \"grafana_ml_model_point\" p\nJOIN \"grafana_ml_model_point_value\" pv \n  ON pv.id_point = p.id\nJOIN \"grafana_ml_model_point_kmeans\" p_cluster\n  ON p_cluster.id_point = p.id\nJOIN \"grafana_ml_model_cluster\" c  \n  ON c.id = p_cluster.id_cluster   \nWHERE p.index=$index AND pv.index=$index AND p_cluster.index=$index AND c.index=$index\nGROUP BY p.id, c.number;  ",
          "refId": "A",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        },
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
          },
          "editorMode": "code",
          "format": "table",
          "hide": false,
          "rawQuery": true,
          "rawSql": "SELECT name AS features_name\nFROM grafana_ml_model_feature \nWHERE grafana_ml_model_feature.index=$index",
          "refId": "B",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        },
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
          },
          "editorMode": "code",
          "format": "table",
          "hide": false,
          "rawQuery": true,
          "rawSql": "SELECT \n  COUNT(DISTINCT cl.id) AS cluster_count\nFROM \n  \"grafana_ml_model_cluster\" cl\nJOIN \n  \"grafana_ml_model_centroid\" c\n  ON c.id_cluster = cl.id\nWHERE \n  c.index = $index AND cl.index = $index;\n",
          "refId": "C",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        },
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
          },
          "editorMode": "code",
          "format": "table",
          "hide": false,
          "rawQuery": true,
          "rawSql": "SELECT \n  cl.number AS number_cluster,  \n  array_to_json(array_agg(c.value ORDER BY f.id)) AS feature_values\nFROM \"grafana_ml_model_centroid\" c\nJOIN \"grafana_ml_model_feature\" f\n  ON f.id = c.id_feature\nJOIN \"grafana_ml_model_cluster\" cl  \n  ON cl.id = c.id_cluster  \nWHERE c.index=$index AND f.index=$index AND cl.index=$index\nGROUP BY cl.number\nORDER BY cl.number\n\n",
          "refId": "D",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        },
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
          },
          "editorMode": "code",
          "format": "table",
          "hide": false,
          "rawQuery": true,
          "rawSql": "SELECT \n  p.name AS point_name, \n  c.number AS number_cluster, \n  array_to_json(array_agg(pv.value ORDER BY pv.id_feature)) AS feature_values\nFROM \"grafana_ml_model_point\" p\nJOIN \"grafana_ml_model_point_value\" pv \n  ON pv.id_point = p.id\nJOIN \"grafana_ml_model_point_kmedoids\" p_cluster\n  ON p_cluster.id_point = p.id\nJOIN \"grafana_ml_model_cluster\" c  \n  ON c.id = p_cluster.id_cluster  \nWHERE p.index=$index  AND pv.index=$index \n      AND p_cluster.index=$index AND c.index=$index \nGROUP BY p.id, c.number",
          "refId": "E",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        },
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
          },
          "editorMode": "code",
          "format": "table",
          "hide": false,
          "rawQuery": true,
          "rawSql": "SELECT \n  p.name AS point_name, \n  c.number AS number_cluster, \n  array_to_json(array_agg(pv.value ORDER BY pv.id_feature)) AS feature_values\nFROM \"grafana_ml_model_point\" p\nJOIN \"grafana_ml_model_point_value\" pv \n  ON pv.id_point = p.id\nJOIN \"grafana_ml_model_point_kmedoids\" p_cluster\n  ON p_cluster.id_point = p.id\nJOIN \"grafana_ml_model_cluster\" c  \n  ON c.id = p_cluster.id_cluster  \nWHERE p.index=$index  AND pv.index=$index \n      AND p_cluster.index=$index AND c.index=$index AND p_cluster.is_medoid=true\nGROUP BY p.id, c.number",
          "refId": "F",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        }
      ],
      "type": "volkovlabs-echarts-panel"
    },
    {
      "datasource": {
        "type": "grafana-postgresql-datasource",
        "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
      },
      "description": "",
      "fieldConfig": {
        "defaults": {
          "color": {
            "mode": "thresholds"
          },
          "mappings": [],
          "thresholds": {
            "mode": "absolute",
            "steps": [
              {
                "color": "#514d4db3",
                "value": null
              }
            ]
          }
        },
        "overrides": []
      },
      "gridPos": {
        "h": 4,
        "w": 5,
        "x": 0,
        "y": 28
      },
      "id": 6,
      "options": {
        "colorMode": "value",
        "graphMode": "area",
        "justifyMode": "center",
        "orientation": "auto",
        "percentChangeColorMode": "standard",
        "reduceOptions": {
          "calcs": [
            "lastNotNull"
          ],
          "fields": "/^Inertia$/",
          "values": false
        },
        "showPercentChange": false,
        "text": {},
        "textMode": "value_and_name",
        "wideLayout": true
      },
      "pluginVersion": "11.2.2",
      "targets": [
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
          },
          "editorMode": "code",
          "format": "table",
          "hide": false,
          "rawQuery": true,
          "rawSql": "SELECT \n  m.silhoutte_coefficient AS \"Silhouette Coefficient\", \n  m.davies_bouldin_index AS \"Davies Bouldin Index\", \n  m.inertia AS \"Inertia\"\nFROM \n  \"grafana_ml_model_metrics_clustering\" m\nWHERE index=$index AND type='$type'",
          "refId": "A",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        }
      ],
      "type": "stat"
    },
    {
      "datasource": {
        "type": "grafana-postgresql-datasource",
        "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
      },
      "fieldConfig": {
        "defaults": {
          "thresholds": {
            "mode": "absolute",
            "steps": [
              {
                "color": "green",
                "value": null
              },
              {
                "color": "red",
                "value": 80
              }
            ]
          }
        },
        "overrides": []
      },
      "gridPos": {
        "h": 12,
        "w": 11,
        "x": 5,
        "y": 28
      },
      "id": 7,
      "options": {
        "afterRender": "",
        "content": "<h3\n    style=\"font-family: 'Arial', sans-serif; font-size: 19px; font-weight: bold; margin-left: 20px; margin-top: 20px;\">\n    Métricas por clúster\n</h3>\n\n<table style=\"font-family: 'Arial', sans-serif; font-size: 22px; margin: 40px auto; border-collapse: collapse; text-align: center;\">\n  <thead>\n    <tr>\n      <th style=\"font-family: 'Arial', sans-serif; font-size: 20px; font-weight: bold; padding: 10px; text-align: center;\">Cluster</th>\n      <th style=\"font-family: 'Arial', sans-serif; font-size: 20px; font-weight: bold; padding: 10px; text-align: center;\">Inertia</th>\n      <th style=\"font-family: 'Arial', sans-serif; font-size: 20px; font-weight: bold; padding: 10px; text-align: center;\">Silhouette Coefficient</th>\n      <th style=\"font-family: 'Arial', sans-serif; font-size: 20px; font-weight: bold; padding: 10px; text-align: center;\">Davies Bouldin Index</th>\n    </tr>\n  </thead>\n  <tbody>\n    {{#each data}}\n      <tr>\n        <td style=\"padding: 10px; background-color: {{getClusterColor name}}\"\">{{name}}</td>\n        <td style=\"padding: 10px; background-color: {{getInertiaColor inertia}}\">{{roundToThree inertia}}</td>\n        <td style=\"padding: 10px; background-color: {{getSilhouetteColor silhoutte_coefficient}}\">{{roundToThree silhoutte_coefficient}}</td>\n        <td style=\"padding: 10px; background-color: {{getDaviesBouldinColor davies_bouldin_index}}\">{{roundToThree davies_bouldin_index}}</td>\n      </tr>\n    {{/each}}\n  </tbody>\n</table>",
        "contentPartials": [],
        "defaultContent": "The query didn't return any results.",
        "editor": {
          "format": "auto",
          "language": "handlebars"
        },
        "editors": [
          "helpers"
        ],
        "externalStyles": [],
        "helpers": "var data = context.data.data;\nvar TRANSPARENCY = 0.6;\n\nvar COLOR_ALL = [\n  `rgba(114, 158, 206, ${TRANSPARENCY})`, // #729ece\n  `rgba(255, 158, 74, ${TRANSPARENCY})`,  // #ff9e4a\n  `rgba(103, 191, 92, ${TRANSPARENCY})`,  // #67bf5c\n  `rgba(237, 102, 93, ${TRANSPARENCY})`,  // #ed665d\n  `rgba(173, 139, 201, ${TRANSPARENCY})`, // #ad8bc9\n  `rgba(168, 120, 142, ${TRANSPARENCY})`, // #a8786e\n  `rgba(237, 151, 202, ${TRANSPARENCY})`, // #ed97ca\n  `rgba(162, 162, 162, ${TRANSPARENCY})`, // #a2a2a2\n  `rgba(205, 204, 93, ${TRANSPARENCY})`,  // #cdcc5d\n  `rgba(109, 204, 218, ${TRANSPARENCY})`  // #6dccda\n];\n\nif (context.grafana.replaceVariables('${color}') == 'Paleta 2') {\n  COLOR_ALL = [\n    `rgba(114, 158, 206, ${TRANSPARENCY})`, // #729ece\n    `rgba(255, 158, 74, ${TRANSPARENCY})`,  // #ff9e4a\n    `rgba(103, 191, 92, ${TRANSPARENCY})`,  // #67bf5c\n    `rgba(237, 102, 93, ${TRANSPARENCY})`,  // #ed665d\n    `rgba(173, 139, 201, ${TRANSPARENCY})`, // #ad8bc9\n    `rgba(168, 120, 142, ${TRANSPARENCY})`, // #a8786e\n    `rgba(237, 151, 202, ${TRANSPARENCY})`, // #ed97ca\n    `rgba(162, 162, 162, ${TRANSPARENCY})`, // #a2a2a2\n    `rgba(205, 204, 93, ${TRANSPARENCY})`,  // #cdcc5d\n    `rgba(109, 204, 218, ${TRANSPARENCY})`  // #6dccda\n  ];\n} else if (context.grafana.replaceVariables('${color}') == 'Paleta 1') {\n  COLOR_ALL = [\n    `rgba(105, 41, 196, ${TRANSPARENCY})`,  // #6929c4\n    `rgba(159, 24, 83, ${TRANSPARENCY})`,   // #9f1853\n    `rgba(25, 143, 56, ${TRANSPARENCY})`,   // #198038\n    `rgba(17, 146, 232, ${TRANSPARENCY})`,  // #1192e8\n    `rgba(87, 4, 8, ${TRANSPARENCY})`,      // #570408\n    `rgba(178, 134, 0, ${TRANSPARENCY})`,   // #b28600\n    `rgba(0, 45, 156, ${TRANSPARENCY})`,    // #002d9c\n    `rgba(238, 83, 139, ${TRANSPARENCY})`,  // #ee538b\n    `rgba(165, 110, 255, ${TRANSPARENCY})`, // #a56eff\n    `rgba(250, 77, 86, ${TRANSPARENCY})`    // #fa4d56\n  ];\n} else if (context.grafana.replaceVariables('${color}') == 'Paleta 3') {\n  COLOR_ALL = [\n    `rgba(158, 1, 66, ${TRANSPARENCY})`,    // #9e0142\n    `rgba(94, 79, 162, ${TRANSPARENCY})`,   // #5e4fa2\n    `rgba(102, 194, 165, ${TRANSPARENCY})`, // #66c2a5\n    `rgba(50, 136, 189, ${TRANSPARENCY})`,  // #3288bd\n    `rgba(244, 109, 67, ${TRANSPARENCY})`,  // #f46d43\n    `rgba(230, 245, 152, ${TRANSPARENCY})`, // #e6f598\n    `rgba(213, 62, 79, ${TRANSPARENCY})`,   // #d53e4f\n    `rgba(253, 97, 236, ${TRANSPARENCY})`,  // #fd61ec\n    `rgba(124, 212, 46, ${TRANSPARENCY})`,  // #7cd42e\n    `rgba(101, 217, 227, ${TRANSPARENCY})`  // #65d9e3\n  ];\n}\n\ncontext.handlebars.registerHelper(\"getClusterColor\", (name) => {\n  return COLOR_ALL[name];\n});\n\nfunction getColor(value, min, max, isBetterHigher) {\n  // Ajustamos la transparencia (alpha) a un valor bajo para mayor transparencia\n  const alpha = 0.3; // Puedes ajustar este valor entre 0 y 1\n\n  if (isBetterHigher) {\n    if (value === max) return `rgba(0, 255, 0, ${alpha})`;  // Mejor valor (verde)\n    if (value === min) return `rgba(255, 0, 0, ${alpha})`;  // Peor valor (rojo)\n    return `rgba(255, 255, 255, ${alpha})`; // Valor intermedio (blanco)\n  } else {\n    if (value === min) return `rgba(0, 255, 0, ${alpha})`;  // Mejor valor (verde)\n    if (value === max) return `rgba(255, 0, 0, ${alpha})`;  // Peor valor (rojo)\n    return `rgba(255, 255, 255, ${alpha})`; // Valor intermedio (blanco)\n  }\n}\n// Registrar la función para obtener el color de \"Inertia\"\ncontext.handlebars.registerHelper(\"getInertiaColor\", (inertia) => {\n  // Obtener los valores de la columna 'inertia'\n  const inertiaValues = data.map(item => item.inertia);\n  const inertiaMin = Math.min(...inertiaValues);  // Valor mínimo en 'inertia'\n  const inertiaMax = Math.max(...inertiaValues);  // Valor máximo en 'inertia'\n  return getColor(inertia, inertiaMin, inertiaMax, false);  // Mejor cuando es mayor\n});\n\n// Registrar la función para obtener el color de \"Silhouette Coefficient\"\ncontext.handlebars.registerHelper(\"getSilhouetteColor\", (silhoutte_coefficient) => {\n  // Obtener los valores de la columna 'silhouette_coefficient'\n  const silhouetteValues = data.map(item => item.silhoutte_coefficient);\n  const silhouetteMin = Math.min(...silhouetteValues);  // Valor mínimo en 'silhouette_coefficient'\n  const silhouetteMax = Math.max(...silhouetteValues);  // Valor máximo en 'silhouette_coefficient'\n  return getColor(silhoutte_coefficient, silhouetteMin, silhouetteMax, true);  // Mejor cuando es mayor\n});\n\n// Registrar la función para obtener el color de \"Davies Bouldin Index\"\ncontext.handlebars.registerHelper(\"getDaviesBouldinColor\", (davies_bouldin_index) => {\n  // Obtener los valores de la columna 'davies_bouldin_index'\n  const dbValues = data.map(item => item.davies_bouldin_index);\n  const dbMin = Math.min(...dbValues);  // Valor mínimo en 'davies_bouldin_index'\n  const dbMax = Math.max(...dbValues);  // Valor máximo en 'davies_bouldin_index'\n  return getColor(davies_bouldin_index, dbMin, dbMax, false);  // Mejor cuando es menor\n});\n\ncontext.handlebars.registerHelper('roundToThree', function (value) {\n  if (value) {\n    return value.toFixed(3);\n  }\n  return value; // Si el valor no es numérico, lo devolvemos tal cual.\n});",
        "renderMode": "allRows",
        "styles": "",
        "wrap": true
      },
      "pluginVersion": "5.4.0",
      "targets": [
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
          },
          "editorMode": "code",
          "format": "table",
          "rawQuery": true,
          "rawSql": "SELECT \n    cl.number AS name,  \n    cl.inertia,\n    cl.silhoutte_coefficient,\n    cl.davies_bouldin_index\nFROM \n    \"grafana_ml_model_cluster\" cl\nWHERE cl.index = $index\n  AND cl.id IN (\n      SELECT DISTINCT c.id \n      FROM \"grafana_ml_model_point\" p\n      JOIN \"grafana_ml_model_point_kmeans\" p_cluster\n        ON p_cluster.id_point = p.id\n      JOIN \"grafana_ml_model_cluster\" c  \n        ON c.id = p_cluster.id_cluster  \n      WHERE p.index = $index\n        AND p_cluster.index = $index\n        AND c.index = $index\n  );",
          "refId": "A",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        }
      ],
      "type": "marcusolsson-dynamictext-panel"
    },
    {
      "datasource": {
        "type": "grafana-postgresql-datasource",
        "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
      },
      "gridPos": {
        "h": 12,
        "w": 8,
        "x": 16,
        "y": 28
      },
      "id": 12,
      "options": {
        "baidu": {
          "callback": "bmapReady",
          "key": ""
        },
        "editor": {
          "format": "auto"
        },
        "editorMode": "code",
        "gaode": {
          "key": "",
          "plugin": "AMap.Scale,AMap.ToolBar"
        },
        "getOption": "if (context.panel.data && context.panel.data.series.length > 0) {\n  var fields = context.panel.data.series[0].fields;\n\n  if (context.grafana.replaceVariables('${type}') == 'KMeans') {\n    fields = context.panel.data.series[0].fields;\n  } else {\n    fields = context.panel.data.series[1].fields;\n  }\n\n  let numberCluster = (fields.find(field => field.name == 'number_cluster')).values;\n  let pointCount = (fields.find(field => field.name == 'points_count')).values;\n\n  let clusters = numberCluster.map((_, index) => ({\n    value: pointCount[index],  // Asocia el número de puntos al cluster\n    name: `cluster ${index}`   // Asigna el nombre \"cluster X\"\n  }));\n\n  // Definir paletas de colores\n  let COLOR_ALL = ['#729ece', '#ff9e4a', '#67bf5c', '#ed665d', '#ad8bc9', '#a8786e', '#ed97ca', '#a2a2a2', '#cdcc5d', '#6dccda'];\n\n  if (context.grafana.replaceVariables('${color}') == 'Paleta 2') {\n    COLOR_ALL = ['#729ece', '#ff9e4a', '#67bf5c', '#ed665d', '#ad8bc9', '#a8786e', '#ed97ca', '#a2a2a2', '#cdcc5d', '#6dccda'];\n  } else if (context.grafana.replaceVariables('${color}') == 'Paleta 1') {\n    COLOR_ALL = ['#6929c4', '#9f1853', '#198038', '#1192e8', '#570408', '#b28600', '#002d9c', '#ee538b', '#a56eff', '#fa4d56'];\n  } else if (context.grafana.replaceVariables('${color}') == 'Paleta 3') {\n    COLOR_ALL = ['#9e0142', '#5e4fa2', '#66c2a5', '#3288bd', '#f46d43', '#e6f598', '#d53e4f', '#fd61ec', '#7cd42e', '#65d9e3'];\n  }\n\n  let clusterColors = clusters.map((_, index) => COLOR_ALL[index % COLOR_ALL.length]);\n\n  // Configuración del gráfico\n  let option = {\n    title: {\n      text: 'Cantidad de puntos por clúster',\n      top: \"2%\",\n      left: \"2%\"\n    },\n    tooltip: {\n      trigger: 'item'\n    },\n    legend: {\n      orient: 'vertical',\n      left: 'right',\n      top: \"15%\",\n      left: '2%',\n    },\n    series: [\n      {\n        type: 'pie',\n        radius: '50%',\n        data: clusters.map((cluster, index) => ({\n          value: cluster.value,\n          name: cluster.name,\n          itemStyle: {\n            color: clusterColors[index]  // Aplica el color correspondiente\n          }\n        })),\n        emphasis: {\n          itemStyle: {\n            shadowBlur: 10,\n            shadowOffsetX: 0,\n            shadowColor: 'rgba(0, 0, 0, 0.5)'\n          }\n        }\n      }\n    ]\n  };\n\n  return option;\n}\n",
        "google": {
          "callback": "gmapReady",
          "key": ""
        },
        "map": "none",
        "renderer": "canvas",
        "themeEditor": {
          "config": "{}",
          "name": "default"
        },
        "visualEditor": {
          "code": "\n",
          "dataset": [],
          "series": []
        }
      },
      "pluginVersion": "6.5.0",
      "targets": [
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
          },
          "editorMode": "code",
          "format": "table",
          "rawQuery": true,
          "rawSql": "SELECT \n  c.number AS number_cluster, \n  COUNT(p.id) AS points_count\nFROM \"grafana_ml_model_point\" p\nJOIN \"grafana_ml_model_point_kmeans\" p_cluster\n  ON p_cluster.id_point = p.id\nJOIN \"grafana_ml_model_cluster\" c  \n  ON c.id = p_cluster.id_cluster  \nWHERE p.index = $index  \n  AND p_cluster.index = $index \n  AND c.index = $index\nGROUP BY c.number\nORDER BY number_cluster\n",
          "refId": "A",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        },
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
          },
          "editorMode": "code",
          "format": "table",
          "hide": false,
          "rawQuery": true,
          "rawSql": "SELECT \n  c.number AS number_cluster, \n  COUNT(p.id) AS points_count\nFROM \"grafana_ml_model_point\" p\nJOIN \"grafana_ml_model_point_kmedoids\" p_cluster\n  ON p_cluster.id_point = p.id\nJOIN \"grafana_ml_model_cluster\" c  \n  ON c.id = p_cluster.id_cluster  \nWHERE p.index = $index  \n  AND p_cluster.index = $index \n  AND c.index = $index\nGROUP BY c.number\nORDER BY number_cluster\n",
          "refId": "B",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        }
      ],
      "type": "volkovlabs-echarts-panel"
    },
    {
      "datasource": {
        "type": "grafana-postgresql-datasource",
        "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
      },
      "description": "",
      "fieldConfig": {
        "defaults": {
          "color": {
            "mode": "thresholds"
          },
          "mappings": [],
          "thresholds": {
            "mode": "absolute",
            "steps": [
              {
                "color": "semi-dark-red"
              },
              {
                "color": "red",
                "value": 0
              },
              {
                "color": "semi-dark-orange",
                "value": 0.25
              },
              {
                "color": "light-yellow",
                "value": 0.3
              },
              {
                "color": "super-light-orange",
                "value": 0.4
              },
              {
                "color": "light-green",
                "value": 0.5
              },
              {
                "color": "green",
                "value": 0.75
              },
              {
                "color": "semi-dark-green",
                "value": 1
              }
            ]
          }
        },
        "overrides": []
      },
      "gridPos": {
        "h": 4,
        "w": 5,
        "x": 0,
        "y": 32
      },
      "id": 5,
      "options": {
        "colorMode": "background",
        "graphMode": "area",
        "justifyMode": "center",
        "orientation": "auto",
        "percentChangeColorMode": "standard",
        "reduceOptions": {
          "calcs": [
            "lastNotNull"
          ],
          "fields": "/^Silhouette Coefficient$/",
          "values": false
        },
        "showPercentChange": false,
        "text": {},
        "textMode": "value_and_name",
        "wideLayout": true
      },
      "pluginVersion": "11.2.2",
      "targets": [
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
          },
          "editorMode": "code",
          "format": "table",
          "rawQuery": true,
          "rawSql": "SELECT \n  m.silhoutte_coefficient AS \"Silhouette Coefficient\", \n  m.davies_bouldin_index AS \"Davies Bouldin Index\", \n  m.inertia AS \"Inertia\"\nFROM \n  \"grafana_ml_model_metrics_clustering\" m\nWHERE index=$index AND type='$type'",
          "refId": "A",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        }
      ],
      "type": "stat"
    },
    {
      "datasource": {
        "type": "grafana-postgresql-datasource",
        "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
      },
      "description": "",
      "fieldConfig": {
        "defaults": {
          "color": {
            "mode": "thresholds"
          },
          "mappings": [],
          "thresholds": {
            "mode": "absolute",
            "steps": [
              {
                "color": "dark-green"
              }
            ]
          }
        },
        "overrides": []
      },
      "gridPos": {
        "h": 4,
        "w": 5,
        "x": 0,
        "y": 36
      },
      "id": 4,
      "options": {
        "colorMode": "background",
        "graphMode": "area",
        "justifyMode": "center",
        "orientation": "auto",
        "percentChangeColorMode": "standard",
        "reduceOptions": {
          "calcs": [
            "lastNotNull"
          ],
          "fields": "/^Davies Bouldin Index$/",
          "values": false
        },
        "showPercentChange": false,
        "text": {},
        "textMode": "value_and_name",
        "wideLayout": true
      },
      "pluginVersion": "11.2.2",
      "targets": [
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
          },
          "editorMode": "code",
          "format": "table",
          "rawQuery": true,
          "rawSql": "SELECT \n  m.silhoutte_coefficient AS \"Silhouette Coefficient\", \n  m.davies_bouldin_index AS \"Davies Bouldin Index\", \n  m.inertia AS \"Inertia\"\nFROM \n  \"grafana_ml_model_metrics_clustering\" m\nWHERE index=$index AND type='$type'",
          "refId": "A",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        }
      ],
      "type": "stat"
    },
    {
      "datasource": {
        "type": "grafana-postgresql-datasource",
        "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
      },
      "description": "",
      "fieldConfig": {
        "defaults": {
          "thresholds": {
            "mode": "absolute",
            "steps": [
              {
                "color": "green"
              }
            ]
          }
        },
        "overrides": [
          {
            "matcher": {
              "id": "byFrameRefID",
              "options": "A"
            },
            "properties": []
          }
        ]
      },
      "gridPos": {
        "h": 21,
        "w": 10,
        "x": 0,
        "y": 40
      },
      "id": 10,
      "options": {
        "afterRender": "import(\"https://esm.sh/d3@7.9.0\").then((d3) => {\n\n  function dendrogram(data, options = {}) {\n    const {\n      width = 750,\n      height = 700,\n      hideLabels = false,\n      paddingBottom = hideLabels ? 20 : 120,\n      innerHeight = height - paddingBottom,\n      innerWidth = width - 10,\n      paddingLeft = 30,\n      cutHeight = undefined,\n      yLabel = \"↑ Altura\",\n      colors = ['#729ece', '#ff9e4a', '#67bf5c', '#ed665d', '#ad8bc9', '#a8786e', '#ed97ca', '#a2a2a2', '#cdcc5d', '#6dccda'],\n      fontFamily = \"Arial, sans-serif\",\n      linkColor = \"grey\",\n      fontSize = 13,\n      strokeWidth = 2.5\n    } = options;\n\n    const svg = d3\n      .create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"viewBox\", [0, 0, width, innerHeight])\n      .attr(\"style\", \"max-width: 100%; height: auto; height: intrinsic;\");\n\n    var clusterLayout = d3.cluster().size([width - paddingLeft * 2, innerHeight]);\n\n    const root = d3.hierarchy(data);\n    const maxHeight = root.data.height;\n\n    const yScaleLinear = d3\n      .scaleLinear()\n      .domain([0, maxHeight])\n      .range([hideLabels ? innerHeight - 35 : innerHeight, 0]);\n\n    const yAxisLinear = d3.axisLeft(yScaleLinear).tickSize(5);\n\n    function transformY(data) {\n      const height = hideLabels ? innerHeight - 15 : innerHeight;\n      return height - (data.data.height / maxHeight) * height;\n    }\n\n    // Traverse through first order children and assign colors\n    let curIndex = -1;\n    if (cutHeight) {\n      curIndex = -1;\n      root.each((child) => {\n        if (\n          child.data.height <= cutHeight &&\n          child.data.height > 0 &&\n          child.parent &&\n          !child.parent.color\n        ) {\n          curIndex++;\n          child.color = colors[curIndex];\n        } else if (child.parent && child.parent.color) {\n          child.color = child.parent.color;\n        }\n      });\n    }\n\n    clusterLayout(root);\n\n    // y-axis\n    svg\n      .append(\"g\")\n      .attr(\"transform\", `translate(0, ${hideLabels ? 20 : 0})`)\n      .append(\"g\")\n      .attr(\"class\", \"axis\")\n      .attr(\"transform\", `translate(${paddingLeft},${hideLabels ? 20 : 0})`)\n      .call(yAxisLinear)\n      .call((g) => g.select(\".domain\").remove())\n      .call((g) =>\n        g\n          .append(\"text\")\n          .attr(\"x\", -paddingLeft)\n          .attr(\"y\", -20)\n          .attr(\"fill\", \"currentColor\")\n          .attr(\"text-anchor\", \"start\")\n          .style(\"font-family\", fontFamily)\n          .style(\"font-size\", `14px`)\n          .text(yLabel)\n      )\n      .selectAll(\".tick\")\n      .classed(\"baseline\", (d) => d == 0)\n      .style(\"font-size\", `${fontSize}px`)\n      .style(\"font-family\", fontFamily);\n\n    // Links\n    root.links().forEach((link) => {\n      svg\n        .append(\"path\")\n        .attr(\"class\", \"link\")\n        .attr(\"stroke\", link.source.color || linkColor)\n        .attr(\"stroke-width\", `${strokeWidth}px`)\n        .attr(\"fill\", \"none\")\n        .attr(\"transform\", `translate(${paddingLeft}, ${hideLabels ? 20 : 0})`)\n        .attr(\"d\", elbow(link));\n    });\n\n    // Nodes\n    root.descendants().forEach((desc) => {\n      if (desc.height == 0 && !hideLabels) {\n        svg\n          .append(\"text\")\n          .attr(\"dx\", -5)\n          .attr(\"dy\", 3)\n          .attr(\"text-anchor\", \"end\")\n          .style(\"font-size\", `${fontSize}px`)\n          .style(\"font-family\", fontFamily)\n          .attr(\n            \"transform\",\n            `translate(${desc.x + paddingLeft},${transformY(desc)}) rotate(270)`\n          )\n          .text(desc.data.name);\n      }\n    });\n\n    // Custom path generator\n    function elbow(d) {\n      return (\n        \"M\" +\n        d.source.x +\n        \",\" +\n        transformY(d.source) +\n        \"H\" +\n        d.target.x +\n        \"V\" +\n        transformY(d.target)\n      );\n    }\n\n    // Leyenda en la parte superior derecha\n    const legendWidth = 120;\n    const legendHeight = curIndex * 30 + 20;\n    const legendGroup = svg.append(\"g\").attr(\"transform\", `translate(${width - legendWidth + 0}, 0)`);\n\n    // Añadir el contenedor de la leyenda\n    legendGroup\n      .append(\"rect\")\n      .attr(\"x\", 0)\n      .attr(\"y\", -1)\n      .attr(\"width\", legendWidth)\n      .attr(\"height\", legendHeight)\n      .style(\"fill\", \"white\")\n      .style(\"stroke\", \"#999\")\n      .style(\"stroke-width\", 0.5);\n\n    // Rectángulos de colores en la leyenda\n    legendGroup\n      .selectAll(\"rect.colorRect\")\n      .data(d3.range(curIndex + 1))\n      .enter()\n      .append(\"rect\")\n      .attr(\"x\", 10)\n      .attr(\"y\", (d, i) => i * 25 + 5)\n      .attr(\"width\", 20)\n      .attr(\"height\", 15)\n      .attr(\"rx\", 5)\n      .attr(\"ry\", 5)\n      .style(\"fill\", (d) => colors[d]);\n\n    // Texto de la leyenda\n    legendGroup\n      .selectAll(\"text\")\n      .data(d3.range(curIndex + 1))\n      .enter()\n      .append(\"text\")\n      .attr(\"x\", 40)\n      .attr(\"y\", (d, i) => i * 25 + 17)\n      .style(\"font-size\", \"12px\")\n      .text((d) => `cluster ${d}`);\n\n    // Add zoom functionality\n    const zoom = d3.zoom()\n      .scaleExtent([0.5, 3])  // Defines the zoom level (min, max)\n      .on(\"zoom\", (event) => {\n        svg.attr(\"transform\", event.transform);  // Apply zoom transformation\n      });\n\n    return svg.node();\n  }\n\n  // Eliminar cualquier gráfico previo en el contenedor\n  const container = document.getElementById(\"dendrogram-container\");\n  container.innerHTML = '';  // Limpia el contenido del contenedor\n\n  var nodes = context.data[0];\n\n  const rootNode = nodes.find(node => node.id_parent === null || node.id_parent === undefined);\n\n  // Función recursiva para construir el árbol\n  function buildHierarchy(nodes, parentId = null) {\n    const children = nodes.filter(node => node.id_parent === parentId);\n\n    if (children.length === 0) return null;\n\n    return children.map(child => ({\n      name: child.name,\n      height: child.height,\n      children: buildHierarchy(nodes, child.id)\n    }));\n  }\n\n  const data = {\n    name: rootNode.name,\n    height: rootNode.height,\n    children: buildHierarchy(nodes, rootNode.id)\n  };\n\n  let cut = context.grafana.replaceVariables('${cut}');\n\n  //Paleta de colores\n  var COLOR_ALL = ['#729ece', '#ff9e4a', '#67bf5c', '#ed665d', '#ad8bc9', '#a8786e', '#ed97ca', '#a2a2a2', '#cdcc5d', '#6dccda'];\n  if (context.grafana.replaceVariables('${color}') == 'Paleta 2') {\n    COLOR_ALL = ['#729ece', '#ff9e4a', '#67bf5c', '#ed665d', '#ad8bc9', '#a8786e', '#ed97ca', '#a2a2a2', '#cdcc5d', '#6dccda'];\n  } else if (context.grafana.replaceVariables('${color}') == 'Paleta 1') {\n    COLOR_ALL = ['#6929c4', '#9f1853', '#198038', '#1192e8', '#570408', '#b28600', '#002d9c', '#ee538b', '#a56eff', '#fa4d56'];\n  } else if (context.grafana.replaceVariables('${color}') == 'Paleta 3') {\n    COLOR_ALL = ['#9e0142', '#5e4fa2', '#66c2a5', '#3288bd', '#f46d43', '#e6f598', '#d53e4f', '#fd61ec', '#7cd42e', '#65d9e3'];\n  }\n\n  const svgElement = dendrogram(data, { cutHeight: cut, colors: COLOR_ALL });\n  container.appendChild(svgElement);\n});\n\n",
        "content": "<!DOCTYPE html>\n<html lang=\"es\">\n\n<body>\n  <h3\n    style=\"font-family: 'Arial', sans-serif; font-size: 19px; font-weight: bold; margin-left: 20px; margin-top: 10px;\">\n    Dendograma\n  </h3>\n\n  <div id=\"dendrogram-container\"></div>\n</body>\n\n</html>",
        "contentPartials": [],
        "defaultContent": "",
        "editor": {
          "format": "auto",
          "language": "html"
        },
        "editors": [
          "afterRender"
        ],
        "externalStyles": [],
        "helpers": "",
        "renderMode": "data",
        "styles": "",
        "wrap": true
      },
      "pluginVersion": "5.4.0",
      "targets": [
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
          },
          "editorMode": "code",
          "format": "table",
          "rawQuery": true,
          "rawSql": "SELECT * \nFROM grafana_ml_model_hierarchical_clustering \nWHERE index=$index2 \nORDER BY id_parent, id\n",
          "refId": "A",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        }
      ],
      "type": "marcusolsson-dynamictext-panel"
    },
    {
      "datasource": {
        "type": "grafana-postgresql-datasource",
        "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
      },
      "description": "",
      "gridPos": {
        "h": 21,
        "w": 14,
        "x": 10,
        "y": 40
      },
      "id": 9,
      "options": {
        "baidu": {
          "callback": "bmapReady",
          "key": ""
        },
        "editor": {
          "format": "auto"
        },
        "editorMode": "code",
        "gaode": {
          "key": "",
          "plugin": "AMap.Scale,AMap.ToolBar"
        },
        "getOption": "if (context.panel.data && context.panel.data.series.length > 0) {\n  const fields = context.panel.data.series[0].fields;\n\n  let id = fields.find(field => field.name === 'id').values;\n  let idParent = fields.find(field => field.name === 'id_parent').values;\n  let name = fields.find(field => field.name === 'name').values;\n  let height = fields.find(field => field.name === 'height').values;\n\n  let cut = parseFloat(context.grafana.replaceVariables('${cut}'));\n\n  let nodes = id.map((item, index) => ({\n    id: id[index],\n    idParent: idParent[index],\n    name: name[index],\n    height: height[index],\n    visited: false,\n  }));\n\n  let rootNode = nodes.find(node => node.idParent === null || node.idParent === undefined);\n\n  // Función recursiva para construir la jerarquía de datos\n  function buildHierarchy(nodes, parentId = null) {\n    const children = nodes.filter(node => node.idParent === parentId);\n\n    if (children.length === 0) return null;\n\n    return children.map(child => ({\n      name: child.name,\n      height: child.height,\n      color: null, // Asegurar el campo para los nodos\n      cluster: -1,\n      children: buildHierarchy(nodes, child.id)\n    }));\n  }\n\n  let data = {\n    name: rootNode.name,\n    height: rootNode.height,\n    color: null,\n    cluster: -1,\n    children: buildHierarchy(nodes, rootNode.id)\n  };\n\n  // Función para asignar colores de acuerdo con el corte\n  //Paleta de colores\n  var colors = ['#729ece', '#ff9e4a', '#67bf5c', '#ed665d', '#ad8bc9', '#a8786e', '#ed97ca', '#a2a2a2', '#cdcc5d', '#6dccda'];\n  if (context.grafana.replaceVariables('${color}') == 'Paleta 2') {\n    colors = ['#729ece', '#ff9e4a', '#67bf5c', '#ed665d', '#ad8bc9', '#a8786e', '#ed97ca', '#a2a2a2', '#cdcc5d', '#6dccda'];\n  } else if (context.grafana.replaceVariables('${color}') == 'Paleta 1') {\n    colors = ['#6929c4', '#9f1853', '#198038', '#1192e8', '#570408', '#b28600', '#002d9c', '#ee538b', '#a56eff', '#fa4d56'];\n  } else if (context.grafana.replaceVariables('${color}') == 'Paleta 3') {\n    colors = ['#9e0142', '#5e4fa2', '#66c2a5', '#3288bd', '#f46d43', '#e6f598', '#d53e4f', '#fd61ec', '#7cd42e', '#65d9e3'];\n  }\n\n  let curIndex = -1; // Índice de color compartido global\n\n  function assignColors(node, parentColor = null, parentIndex = -1) {\n    if (node.height <= cut && !parentColor) {\n      curIndex++;\n      node.color = colors[curIndex % colors.length];\n      node.cluster = curIndex;\n      node.itemStyle = {\n        color: node.color\n      };\n      node.lineStyle = {\n        color: node.color,\n      };\n    } else if (node.height <= cut && parentColor) {\n      node.color = parentColor;\n      node.cluster = parentIndex;\n\n      node.itemStyle = {\n        color: node.color,\n      };\n      node.lineStyle = {\n        color: node.color,\n      };\n    }\n\n    // Recorre los hijos de forma recursiva\n    if (node.children) {\n      node.children.forEach(child => assignColors(child, node.color, node.cluster));\n    }\n  }\n\n  assignColors(data);\n\n  // Crear elementos del cartel para clústeres\n  var clusterLegend = [];\n  for (var i = 0; i <= curIndex; i++) {\n    clusterLegend.push({\n      type: 'rect',\n      left: 10,\n      top: 10 + i * 30,\n      shape: {\n        width: 20,\n        height: 15,\n        r: 4\n      },\n      style: {\n        fill: colors[i]\n      }\n    });\n    clusterLegend.push({\n      type: 'text',\n      left: 40,\n      top: 10 + i * 30,\n      style: {\n        text: `cluster ${i}`,\n        fill: '#000',\n        font: '13px Arial'\n      }\n    });\n  }\n\n  const option = {\n    title: {\n      text: 'Árbol',\n      top: \"2%\",\n      left: \"2%\"\n    },\n    tooltip: {\n      trigger: \"item\",\n      triggerOn: \"mousemove\",\n      formatter: function (params) {\n        let tooltipText = `Nombre: ${params.data.name} <br> Altura: ${params.data.height} <br> Clúster: ${params.data.cluster}`;\n        return tooltipText;\n      }\n    },\n    series: [\n      {\n        type: \"tree\",\n        data: [data],\n        left: \"2%\",\n        right: \"2%\",\n        top: \"8%\",\n        bottom: \"14%\",\n        symbol: \"emptyCircle\",\n        symbolSize: 12,\n        edgeShape: 'polyline',\n        orient: \"vertical\",\n        expandAndCollapse: true,\n        initialTreeDepth: 6,\n        label: {\n          show: false,\n          position: \"top\",\n          rotate: -90,\n          verticalAlign: \"middle\",\n          align: \"right\",\n          fontSize: 13,\n        },\n        leaves: {\n          label: {\n            show: true,\n            position: \"bottom\",\n            rotate: -90,\n            verticalAlign: \"middle\",\n            align: \"left\",\n          },\n        },\n        animationDurationUpdate: 750,\n      },\n    ],\n    graphic: [\n      {\n        type: 'group',\n        left: '88%',\n        top: '2%',\n        children: [\n          {\n            type: 'rect',\n            left: '0',\n            top: '0',\n            shape: {\n              width: 120,\n              height: (curIndex + 1) * 30 + 10\n            },\n            style: {\n              fill: '#fff',\n              stroke: '#999',\n              lineWidth: 1\n            }\n          },\n          ...clusterLegend\n        ]\n      }\n    ]\n  };\n\n  return option;\n}\n",
        "google": {
          "callback": "gmapReady",
          "key": ""
        },
        "map": "none",
        "renderer": "canvas",
        "themeEditor": {
          "config": "{}",
          "name": "default"
        },
        "visualEditor": {
          "code": "return {\n  dataset: context.editor.dataset,\n  series: context.editor.series,\n  xAxis: {\n    type: 'time',\n  },\n  yAxis: {\n    type: 'value',\n    min: 'dataMin',\n  },\n}\n",
          "dataset": [],
          "series": []
        }
      },
      "pluginVersion": "6.5.0",
      "targets": [
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
          },
          "editorMode": "code",
          "format": "table",
          "rawQuery": true,
          "rawSql": "SELECT id, id_parent, name, height\nFROM grafana_ml_model_hierarchical_clustering \nWHERE index=$index2 ",
          "refId": "A",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        }
      ],
      "type": "volkovlabs-echarts-panel"
    },
    {
      "datasource": {
        "type": "grafana-postgresql-datasource",
        "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
      },
      "fieldConfig": {
        "defaults": {
          "thresholds": {
            "mode": "absolute",
            "steps": [
              {
                "color": "green"
              },
              {
                "color": "red",
                "value": 80
              }
            ]
          }
        },
        "overrides": []
      },
      "gridPos": {
        "h": 19,
        "w": 9,
        "x": 0,
        "y": 61
      },
      "id": 11,
      "options": {
        "afterRender": "import(\"https://esm.sh/d3@7.9.0\").then((d3) => {\n  var width = 620;\n  var height = 620;\n  var radius = width / 2;\n\n  var svgContainer = d3.select(\"#my_dataviz_radial\");\n  svgContainer.selectAll(\"*\").remove();\n\n  var svg = svgContainer\n    .append(\"svg\")\n    .attr(\"width\", width)\n    .attr(\"height\", height)\n    .append(\"g\")\n    .attr(\"transform\", \"translate(\" + radius + \",\" + radius + \")\");\n\n  var nodes = context.data[0];\n\n  const rootNode = nodes.find(node => node.id_parent === null || node.id_parent === undefined);\n\n  function buildHierarchy(nodes, parentId = null) {\n    const children = nodes.filter(node => node.id_parent === parentId);\n    if (children.length === 0) return null;\n    return children.map(child => ({\n      name: child.name,\n      value: child.height,\n      cluster: -1,\n      children: buildHierarchy(nodes, child.id)\n    }));\n  }\n\n  const data = {\n    name: rootNode.name,\n    value: rootNode.height,\n    cluster: -1,\n    children: buildHierarchy(nodes, rootNode.id)\n  };\n\n  var colors = ['#729ece', '#ff9e4a', '#67bf5c', '#ed665d', '#ad8bc9', '#a8786e', '#ed97ca', '#a2a2a2', '#cdcc5d', '#6dccda'];\n  if (context.grafana.replaceVariables('${color}') == 'Paleta 2') {\n    colors = ['#729ece', '#ff9e4a', '#67bf5c', '#ed665d', '#ad8bc9', '#a8786e', '#ed97ca', '#a2a2a2', '#cdcc5d', '#6dccda'];\n  } else if (context.grafana.replaceVariables('${color}') == 'Paleta 1') {\n    colors = ['#6929c4', '#9f1853', '#198038', '#1192e8', '#570408', '#b28600', '#002d9c', '#ee538b', '#a56eff', '#fa4d56'];\n  } else if (context.grafana.replaceVariables('${color}') == 'Paleta 3') {\n    colors = ['#9e0142', '#5e4fa2', '#66c2a5', '#3288bd', '#f46d43', '#e6f598', '#d53e4f', '#fd61ec', '#7cd42e', '#65d9e3'];\n  }\n\n  const cutThreshold = context.grafana.replaceVariables('${cut}');\n  let curIndex = -1;\n\n  function assignDynamicClusters(node, parentCluster = -1) {\n    if (node.value <= cutThreshold && parentCluster == -1) {\n      curIndex++;\n      node.cluster = curIndex;\n    } else if (parentCluster != -1) {\n      node.cluster = parentCluster;\n    }\n    if (node.children) {\n      node.children.forEach(child => assignDynamicClusters(child, node.cluster));\n    }\n  }\n\n  assignDynamicClusters(data);\n\n  var cluster = d3.cluster().size([360, radius - 60]);\n  var root = d3.hierarchy(data, function (d) {\n    return d.children;\n  });\n\n  cluster(root);\n\n  var linksGenerator = d3.linkRadial()\n    .angle(d => d.x / 180 * Math.PI)\n    .radius(d => d.y);\n\n  svg.selectAll('path')\n    .data(root.links())\n    .enter()\n    .append('path')\n    .attr(\"d\", linksGenerator)\n    .style(\"fill\", 'none')\n    .attr(\"stroke\", '#ccc');\n\n  var colorScale = d3.scaleOrdinal().domain(d3.range(colors.length)).range(colors);\n\n  svg.selectAll(\"g\")\n    .data(root.descendants())\n    .enter()\n    .append(\"g\")\n    .attr(\"transform\", function (d) {\n      return \"rotate(\" + (d.x - 90) + \")translate(\" + d.y + \")\";\n    })\n    .each(function (d) {\n      var circle = d3.select(this).append(\"circle\")\n        .attr(\"r\", !d.children ? 10 : 7)\n        .attr(\"stroke\", \"black\")\n        .style(\"stroke-width\", 1);\n\n      if (d.data.cluster != -1) {\n        circle.style(\"fill\", colorScale(d.data.cluster));\n      } else {\n        circle.style(\"fill\", \"#ccc\");\n      }\n\n      if (!d.children) {\n        d3.select(this).append(\"text\")\n          .attr(\"x\", 12)\n          .attr(\"y\", 3)\n          .style(\"font-size\", \"12px\")\n          .text(d.data.name);\n      }\n    });\n\n  /*\n    // Agregar cartel con borde\n    var legendGroup = svgContainer\n      .append(\"svg\")\n      .attr(\"width\", 150)\n      .attr(\"height\", colors.length * 25 + 350)\n      .attr(\"x\", width - 170)\n      .attr(\"y\", 10)\n      .append(\"g\");\n  \n    // Rectángulos de color\n    legendGroup.selectAll(\"rect\")\n      .data(d3.range(curIndex + 1))\n      .enter()\n      .append(\"rect\")\n      .attr(\"x\", 10)\n      .attr(\"y\", (d, i) => i * 25 + 25) // Ajustar posición\n      .attr(\"width\", 20)\n      .attr(\"height\", 15)\n      .attr(\"rx\", 5) // Bordes redondeados\n      .attr(\"ry\", 5) // Bordes redondeados\n      .style(\"fill\", d => colorScale(d));\n  \n    // Texto de la leyenda\n    legendGroup.selectAll(\"text\")\n      .data(d3.range(curIndex + 1))\n      .enter()\n      .append(\"text\")\n      .attr(\"x\", 40)\n      .attr(\"y\", (d, i) => i * 25 + 12 + 25) // Ajustar la posición\n      .style(\"font-size\", \"12px\")\n      .text(d => `cluster ${d}`);*/\n\n});\n",
        "content": "<!DOCTYPE html>\n<html lang=\"es\">\n\n<head>\n  <meta charset=\"utf-8\">\n</head>\n\n<body>\n  <h3\n    style=\"font-family: 'Arial', sans-serif; font-size: 19px; font-weight: bold; margin-left: 20px; margin-top: 10px;\">\n    Dendograma radial\n  </h3>\n\n  <!-- Este es el contenedor donde se mostrará el gráfico -->\n  <div id=\"my_dataviz_radial\"></div>\n</body>\n\n</html>",
        "contentPartials": [],
        "defaultContent": "The query didn't return any results.",
        "editor": {
          "format": "auto",
          "language": "markdown"
        },
        "editors": [
          "afterRender"
        ],
        "externalStyles": [],
        "helpers": "",
        "renderMode": "data",
        "styles": "",
        "wrap": true
      },
      "pluginVersion": "5.4.0",
      "targets": [
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
          },
          "editorMode": "code",
          "format": "table",
          "rawQuery": true,
          "rawSql": "SELECT *\nFROM grafana_ml_model_hierarchical_clustering \nWHERE index=$index2 \nORDER BY id_parent, id\n",
          "refId": "A",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        }
      ],
      "type": "marcusolsson-dynamictext-panel"
    },
    {
      "datasource": {
        "type": "grafana-postgresql-datasource",
        "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
      },
      "gridPos": {
        "h": 19,
        "w": 15,
        "x": 9,
        "y": 61
      },
      "id": 13,
      "options": {
        "baidu": {
          "callback": "bmapReady",
          "key": ""
        },
        "editor": {
          "format": "auto"
        },
        "editorMode": "code",
        "gaode": {
          "key": "",
          "plugin": "AMap.Scale,AMap.ToolBar"
        },
        "getOption": "if (context.panel.data && context.panel.data.series.length > 0) {\n  const fieldsPoints = context.panel.data.series[0].fields;\n  const fieldsNodes = context.panel.data.series[1].fields;\n  const fieldsFeatures = context.panel.data.series[2].fields;\n\n  let pointNames = (fieldsPoints.find(fields => fields.name == 'point_name')).values;\n  let pointIds = (fieldsPoints.find(fields => fields.name == 'id_point')).values;\n  let pointValues = (fieldsPoints.find(fields => fields.name == 'feature_values')).values;\n  let id = fieldsNodes.find(field => field.name === 'id').values;\n  let idParent = fieldsNodes.find(field => field.name === 'id_parent').values;\n  let name = fieldsNodes.find(field => field.name === 'name').values;\n  let height = fieldsNodes.find(field => field.name === 'height').values;\n  let featuresName = (fieldsFeatures.find(fields => fields.name == 'name')).values;\n\n  let parsedValuesPoints = pointValues.map(value => JSON.parse(value));\n\n  //Paleta de colores\n  var COLOR_ALL = ['#729ece', '#ff9e4a', '#67bf5c', '#ed665d', '#ad8bc9', '#a8786e', '#ed97ca', '#a2a2a2', '#cdcc5d', '#6dccda'];\n  if (context.grafana.replaceVariables('${color}') == 'Paleta 2') {\n    COLOR_ALL = ['#729ece', '#ff9e4a', '#67bf5c', '#ed665d', '#ad8bc9', '#a8786e', '#ed97ca', '#a2a2a2', '#cdcc5d', '#6dccda'];\n  } else if (context.grafana.replaceVariables('${color}') == 'Paleta 1') {\n    COLOR_ALL = ['#6929c4', '#9f1853', '#198038', '#1192e8', '#570408', '#b28600', '#002d9c', '#ee538b', '#a56eff', '#fa4d56'];\n  } else if (context.grafana.replaceVariables('${color}') == 'Paleta 3') {\n    COLOR_ALL = ['#9e0142', '#5e4fa2', '#66c2a5', '#3288bd', '#f46d43', '#e6f598', '#d53e4f', '#fd61ec', '#7cd42e', '#65d9e3'];\n  }\n\n  let cut = parseFloat(context.grafana.replaceVariables('${cut}'));\n\n  let nodes = id.map((item, index) => ({\n    id: id[index],\n    idParent: idParent[index],\n    name: name[index],\n    height: height[index],\n    visited: false,\n  }));\n\n  let rootNode = nodes.find(node => node.idParent === null || node.idParent === undefined);\n\n  // Función recursiva para construir la jerarquía de datos\n  function buildHierarchy(nodes, parentId = null) {\n    const children = nodes.filter(node => node.idParent === parentId);\n\n    if (children.length === 0) return null;\n\n    return children.map(child => ({\n      id: child.id,\n      name: child.name,\n      height: child.height,\n      color: null, // Asegurar el campo para los nodos\n      cluster: -1,\n      children: buildHierarchy(nodes, child.id)\n    }));\n  }\n\n  let data = {\n    id: rootNode.id,\n    name: rootNode.name,\n    height: rootNode.height,\n    color: null,\n    cluster: -1,\n    children: buildHierarchy(nodes, rootNode.id)\n  };\n\n  // Función para asignar colores de acuerdo con el corte\n  //Paleta de colores\n  var colors = ['#729ece', '#ff9e4a', '#67bf5c', '#ed665d', '#ad8bc9', '#a8786e', '#ed97ca', '#a2a2a2', '#cdcc5d', '#6dccda'];\n  if (context.grafana.replaceVariables('${color}') == 'Paleta 1') {\n    colors = ['#729ece', '#ff9e4a', '#67bf5c', '#ed665d', '#ad8bc9', '#a8786e', '#ed97ca', '#a2a2a2', '#cdcc5d', '#6dccda'];\n  } else if (context.grafana.replaceVariables('${color}') == 'Paleta 2') {\n    colors = ['#6929c4', '#9f1853', '#198038', '#1192e8', '#570408', '#b28600', '#002d9c', '#ee538b', '#a56eff', '#fa4d56'];\n  } else if (context.grafana.replaceVariables('${color}') == 'Paleta 3') {\n    colors = ['#9e0142', '#5e4fa2', '#66c2a5', '#3288bd', '#f46d43', '#e6f598', '#d53e4f', '#fd61ec', '#7cd42e', '#65d9e3'];\n  }\n\n  let curIndex = -1; // Índice de color compartido global\n\n  function assignColors(node, parentColor = null, parentIndex = -1) {\n    if (node.height <= cut && !parentColor) {\n      curIndex++;\n      node.color = colors[curIndex % colors.length];\n      node.cluster = curIndex;\n      node.itemStyle = {\n        color: node.color\n      };\n      node.lineStyle = {\n        color: node.color,\n      };\n    } else if (node.height <= cut && parentColor) {\n      node.color = parentColor;\n      node.cluster = parentIndex;\n\n      node.itemStyle = {\n        color: node.color,\n      };\n      node.lineStyle = {\n        color: node.color,\n      };\n    }\n\n    // Recorre los hijos de forma recursiva\n    if (node.children) {\n      node.children.forEach(child => assignColors(child, node.color, node.cluster));\n    }\n  }\n\n  assignColors(data);\n\n  var CLUSTER_COUNT = curIndex + 1;\n  var DIENSIION_CLUSTER_INDEX = 2;\n  var selectedFeatureX = 0;\n  var selectedFeatureY = 1;\n\n  // Visual map\n  var pieces = [];\n  for (var i = 0; i < CLUSTER_COUNT; i++) {\n    pieces.push({\n      value: i,\n      label: 'clúster ' + i,\n      color: COLOR_ALL[i]\n    });\n  }\n\n  // Función para extraer nodos hoja\n  function extractLeafNodes(hierarchy, leafNodes = []) {\n    if (!hierarchy.children || hierarchy.children.length === 0) {\n      leafNodes.push({ id: hierarchy.id, cluster: hierarchy.cluster });\n    } else {\n      hierarchy.children.forEach(child => extractLeafNodes(child, leafNodes));\n    }\n    return leafNodes;\n  }\n\n  // Generar el arreglo de clústeres ordenado por ID\n  function getClusterArrayById(hierarchy) {\n    const leafNodes = extractLeafNodes(hierarchy); // Extraer nodos hoja\n    const sortedLeafNodes = leafNodes.sort((a, b) => a.id - b.id);\n    return sortedLeafNodes.map(node => node.cluster);\n  }\n\n  // Ejemplo de uso\n  let pointClusters = getClusterArrayById(data);\n\n  // Puntos \n  const pointSeriesData = createSeriesData(parsedValuesPoints, pointClusters, selectedFeatureX, selectedFeatureY);\n\n  console.log(pointSeriesData)\n  // Centroides \n  const centroidSeriesData = createSeriesCentroidData(parsedValuesPoints, pointClusters, selectedFeatureX, selectedFeatureY);\n\n  // Lógica para la selección\n  if (context.grafana.replaceVariables('${index2}')) {\n    let dom = context.panel.chart.getDom();\n    let nodeList = dom.childNodes;\n\n    if (nodeList.length > 2) {\n      nodeList[0].remove();\n    }\n\n    const container = document.createElement(\"div\");\n    container.style.display = \"flex\";\n    container.style.flexDirection = \"row\";\n    container.style.width = \"100%\";\n\n    const title = document.createElement(\"h3\");\n    title.innerHTML = \"Diagrama de dispersión\";\n    title.style.fontWeight = \"bold\";\n    title.style.fontSize = \"18px\";\n    title.style.fontFamily = \"'Arial', sans-serif\";\n    title.style.flexGrow = \"1\";\n    title.style.marginLeft = \"20px\";\n    title.style.marginTop = \"20px\";\n\n    const rightContainer = document.createElement(\"div\");\n    rightContainer.style.display = \"flex\";\n    rightContainer.style.flexDirection = \"column\";\n    rightContainer.style.alignItems = \"flex-end\";\n    rightContainer.style.marginLeft = \"10px\";\n\n    // Eje X\n    const xAxisContainer = document.createElement(\"div\");\n    xAxisContainer.style.display = \"flex\";\n    xAxisContainer.style.alignItems = \"center\";\n    xAxisContainer.style.marginBottom = \"2px\";\n\n    const xAxisLabel = document.createElement(\"span\");\n    xAxisLabel.innerHTML = \"Eje x:\";\n    xAxisLabel.style.marginRight = \"6px\";\n    xAxisLabel.style.fontFamily = \"'Arial', sans-serif\";\n    xAxisLabel.style.fontWeight = \"bold\";\n    xAxisLabel.style.fontSize = \"14px\";\n    xAxisLabel.style.marginTop = \"20px\";\n\n    const selectListX = document.createElement(\"select\");\n    selectListX.id = \"selectX\";\n    selectListX.style.fontFamily = \"'Arial', sans-serif\";\n    selectListX.style.border = \"1px solid gray\";\n    selectListX.style.borderRadius = \"8px\";\n    selectListX.style.padding = \"5px\";\n    selectListX.style.minWidth = \"120px\";\n    selectListX.style.marginTop = \"20px\";\n    selectListX.style.marginRight = \"10px\";\n\n    // Eje Y\n    const yAxisContainer = document.createElement(\"div\");\n    yAxisContainer.style.display = \"flex\";\n    yAxisContainer.style.alignItems = \"center\";\n    yAxisContainer.style.marginBottom = \"2px\";\n\n    const yAxisLabel = document.createElement(\"span\");\n    yAxisLabel.innerHTML = \"Eje y:\";\n    yAxisLabel.style.marginRight = \"6px\";\n    yAxisLabel.style.fontFamily = \"'Arial', sans-serif\";\n    yAxisLabel.style.fontWeight = \"bold\";\n    yAxisLabel.style.fontSize = \"14px\";\n\n    const selectListY = document.createElement(\"select\");\n    selectListY.id = \"selectY\";\n    selectListY.style.fontFamily = \"'Arial', sans-serif\";\n    selectListY.style.border = \"1px solid gray\";\n    selectListY.style.borderRadius = \"8px\";\n    selectListY.style.padding = \"5px\";\n    selectListY.style.minWidth = \"120px\";\n    selectListY.style.marginRight = \"10px\";\n\n    featuresName.forEach((value, index) => {\n      const optionX = document.createElement(\"option\");\n      optionX.value = index;\n      optionX.text = value;\n      selectListX.appendChild(optionX);\n\n      const optionY = document.createElement(\"option\");\n      optionY.value = index;\n      optionY.text = value;\n      selectListY.appendChild(optionY);\n    });\n\n    selectListY.value = selectedFeatureY;\n\n    selectListX.addEventListener(\"change\", () => {\n      selectedFeatureX = parseInt(selectListX.value);\n      updateChartData();\n    });\n\n    selectListY.addEventListener(\"change\", () => {\n      selectedFeatureY = parseInt(selectListY.value);\n      updateChartData();\n    });\n\n    // Añadiendo todo a rightContainer\n    xAxisContainer.appendChild(xAxisLabel);\n    xAxisContainer.appendChild(selectListX);\n    yAxisContainer.appendChild(yAxisLabel);\n    yAxisContainer.appendChild(selectListY);\n\n    rightContainer.appendChild(xAxisContainer);\n    rightContainer.appendChild(yAxisContainer);\n\n    // Añadiendo todo al container\n    container.appendChild(title);\n    container.appendChild(rightContainer);\n\n    dom.insertBefore(container, dom.firstChild);\n  }\n\n  // Función para actualizar el gráfico después de un cambio en la selección\n  function updateChartData() {\n    const pointSeriesData = createSeriesData(parsedValuesPoints, pointClusters, selectedFeatureX, selectedFeatureY);\n\n    console.log('hola');\n    console.log(pointClusters);\n\n    const centroidSeriesData = createSeriesCentroidData(parsedValuesPoints, pointClusters, selectedFeatureX, selectedFeatureY);\n\n    context.panel.chart.setOption({\n      xAxis: {\n        name: featuresName[selectedFeatureX],\n        min: () => calculateMargin(pointValues, selectedFeatureX)\n      },\n      yAxis: {\n        name: featuresName[selectedFeatureY],\n        min: () => calculateMargin(pointValues, selectedFeatureY)\n      },\n      series: [\n        {\n          name: 'Puntos',\n          data: pointSeriesData\n        },\n        {\n          name: 'Centroides',\n          data: centroidSeriesData\n        }\n      ]\n    });\n  }\n\n  option = {\n    tooltip: {\n      position: 'top',\n      formatter: function (params) {\n        const seriesIndex = params.seriesIndex;\n        const dataIndex = params.dataIndex;\n\n        let featureValues = (seriesIndex === 0 ? parsedValuesPoints : parsedValuesCentroids)[dataIndex];\n        let clusterId = (seriesIndex === 0 ? pointClusters : centroidClusters)[dataIndex];\n        const pointName = (seriesIndex === 0 ? pointNames : 'centroidNames')[dataIndex];\n\n        const featureName1 = featuresName[selectedFeatureX];\n        const featureName2 = featuresName[selectedFeatureY];\n\n        return `\n            <div><strong>${pointName}</strong></div>\n            <div><strong>Cluster: ${clusterId}</strong></div>\n            <div>${featureName1}: ${featureValues[selectedFeatureX]}</div>\n            <div>${featureName2}: ${featureValues[selectedFeatureY]}</div>\n          `;\n      }\n    },\n    visualMap: {\n      type: 'piecewise',\n      top: '22%',\n      min: 0,\n      max: CLUSTER_COUNT - 1,\n      left: 10,\n      dimension: DIENSIION_CLUSTER_INDEX,\n      pieces: pieces,\n      textStyle: {\n        fontSize: 14\n      },\n      inRange: {\n        color: COLOR_ALL\n      }\n    },\n    grid: {\n      bottom: \"23%\",\n      containLabel: true,\n      left: \"135\",\n      right: \"4%\",\n      top: \"3%\"\n    },\n    xAxis: {\n      type: 'value',\n      name: featuresName[selectedFeatureX],\n      nameLocation: 'middle',\n      nameGap: 20,\n      min: () => calculateMargin(pointValues, selectedFeatureX)\n    },\n    yAxis: {\n      type: 'value',\n      name: featuresName[selectedFeatureY],\n      nameLocation: 'middle',\n      nameGap: 30,\n      min: () => calculateMargin(pointValues, selectedFeatureY)\n    },\n    legend: {\n      data: ['Puntos', 'Centroides'],\n      top: '8%',\n      left: '1%',\n      orient: 'vertical',\n      textStyle: {\n        fontSize: 14\n      },\n      itemStyle: {\n        color: '#fff',\n        borderColor: '#000',\n        borderWidth: 1.5\n      }\n    },\n    series: [\n      {\n        name: 'Puntos',\n        type: 'scatter',\n        encode: { tooltip: [0, 1] },\n        symbolSize: 15,\n        symbol: getShape(context.grafana.replaceVariables('${shape}')),\n        itemStyle: {\n          color: '#888',\n          borderColor: '#555',\n        },\n        data: pointSeriesData,\n      },\n      {\n        name: 'Centroides',\n        type: 'scatter',\n        encode: { tooltip: [0, 1] },\n        symbol: `path://${getSvgPathCentroid()}`,\n        symbolSize: 25,\n        itemStyle: {\n          color: '#888',\n          borderColor: '#111',\n        },\n        data: centroidSeriesData,\n      }\n    ]\n  };\n  return option;\n}\n\n//Array dada 2 dimensiones y con el clúster \nfunction createSeriesData(values, clusters, dim1Index, dim2Index) {\n  return values.map((value, index) => {\n    const dim1 = value[dim1Index];\n    const dim2 = value[dim2Index];\n    const cluster = clusters[index];\n    const color = COLOR_ALL[cluster];\n\n    return {\n      value: [dim1, dim2, cluster],\n      itemStyle: {\n        color: color\n      }\n    };\n  });\n}\n\nfunction createSeriesCentroidData(values, clusters, dim1Index, dim2Index) {\n  const clusterMap = {};\n\n  // Agrupar puntos por clúster\n  values.forEach((value, index) => {\n    const cluster = clusters[index];\n    if (!clusterMap[cluster]) {\n      clusterMap[cluster] = [];\n    }\n    clusterMap[cluster].push(value);\n  });\n\n  // Calcular centroides\n  return Object.keys(clusterMap).map(cluster => {\n    const clusterPoints = clusterMap[cluster];\n    const dim1Sum = clusterPoints.reduce((sum, point) => sum + point[dim1Index], 0);\n    const dim2Sum = clusterPoints.reduce((sum, point) => sum + point[dim2Index], 0);\n    const count = clusterPoints.length;\n\n    return {\n      value: [dim1Sum / count, dim2Sum / count, parseInt(cluster)],\n      itemStyle: {\n        color: COLOR_ALL[cluster],\n        borderColor: \"#000\" // Resaltar los centroides\n      },\n    };\n  });\n}\n\n//Calcular el margen del 5% basado en el rango de los datos\nfunction calculateMargin(values, axisIndex) {\n  const axisValues = values.map(value => JSON.parse(value)[axisIndex]);\n  const minValue = Math.min(...axisValues);\n  const maxValue = Math.max(...axisValues);\n  const range = maxValue - minValue;\n  const margin = range * 0.04;\n  const result = minValue - margin;\n\n  return parseFloat(result.toFixed(4));\n}\n\n//Símbolo de los centroides\nfunction getSvgPathCentroid() {\n  return \"M2750 12751 c-116 -26 -186 -52 -295 -110 -299 -157 -485 -326 -1104 \" +\n    \"-1004 -79 -86 -271 -277 -427 -422 -320 -301 -448 -431 -570 -584 -148 -183 \" +\n    \"-238 -344 -290 -517 -24 -78 -28 -106 -28 -234 -1 -176 13 -238 89 -395 133 \" +\n    \"-276 388 -564 1000 -1130 276 -255 599 -572 1175 -1154 437 -441 795 -808 795 \" +\n    \"-814 0 -12 -1837 -1835 -2267 -2250 -525 -506 -711 -761 -804 -1098 -13 -46 \" +\n    \"-18 -101 -18 -194 0 -152 19 -236 87 -375 60 -123 147 -232 362 -457 105 -109 \" +\n    \"323 -340 485 -513 580 -622 785 -826 1149 -1146 240 -212 346 -280 509 -326 \" +\n    \"111 -32 292 -31 417 1 355 92 700 348 1234 916 410 436 1057 1110 1286 1340 \" +\n    \"444 446 749 702 869 730 33 7 53 -13 1756 -1730 698 -703 847 -844 1040 -981 \" +\n    \"419 -297 777 -346 1153 -158 203 101 279 166 802 683 595 589 869 857 1067 \" +\n    \"1044 373 352 518 591 535 882 12 221 -66 463 -232 717 -184 281 -425 535 -985 \" +\n    \"1039 -219 197 -451 424 -900 879 -333 337 -656 658 -719 714 -155 137 -176 \" +\n    \"165 -175 227 0 38 8 59 35 99 19 27 463 474 987 992 1735 1716 1773 1755 1841 \" +\n    \"1853 79 114 132 225 162 340 20 75 23 114 23 230 -1 162 -19 243 -83 381 -83 \" +\n    \"177 -180 299 -487 614 -116 118 -334 357 -486 531 -456 523 -681 753 -933 954 \" +\n    \"-162 130 -277 205 -420 275 -404 199 -747 166 -1087 -104 -58 -47 -211 -190 \" +\n    \"-340 -319 -262 -263 -2071 -2052 -2303 -2278 -161 -156 -197 -182 -261 -183 \" +\n    \"-57 -1 -98 30 -200 149 -47 55 -208 224 -358 375 -1608 1625 -2172 2191 -2240 \" +\n    \"2249 -224 189 -409 268 -646 277 -89 3 -134 0 -200 -15z\";\n}\n\n\nfunction getShape(shape) {\n  let seLectedShapeValue = 'circle';\n\n  if (shape == 'Círculo') {\n    seLectedShapeValue = 'circle';\n  } else if (shape == 'Triángulo') {\n    seLectedShapeValue = 'triangle';\n  } else if (shape == 'Rectángulo') {\n    seLectedShapeValue = 'rect';\n  } else if (shape == 'Pin') {\n    seLectedShapeValue = 'pin';\n  }\n\n  return seLectedShapeValue;\n}\n\n",
        "google": {
          "callback": "gmapReady",
          "key": ""
        },
        "map": "amap",
        "renderer": "canvas",
        "themeEditor": {
          "config": "{}",
          "name": "default"
        },
        "visualEditor": {
          "code": "\n",
          "dataset": [],
          "series": []
        }
      },
      "pluginVersion": "6.5.0",
      "targets": [
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
          },
          "editorMode": "code",
          "format": "table",
          "hide": false,
          "rawQuery": true,
          "rawSql": "SELECT \n  hc.name AS point_name,\n  hc.id AS id_point,\n  array_to_json(array_agg(pv.value ORDER BY pv.id_feature)) AS feature_values\nFROM \"grafana_ml_model_hierarchical_clustering\" hc\nJOIN \"grafana_ml_model_point_value\" pv \n  ON pv.id_point = hc.id_point\nWHERE hc.index = $index2 \n      AND pv.index = $index2\nGROUP BY hc.id, hc.name;",
          "refId": "A",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        },
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
          },
          "editorMode": "code",
          "format": "table",
          "hide": false,
          "rawQuery": true,
          "rawSql": "SELECT id, id_parent, name, height\nFROM grafana_ml_model_hierarchical_clustering \nWHERE index=$index2 ",
          "refId": "B",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        },
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
          },
          "editorMode": "code",
          "format": "table",
          "hide": false,
          "rawQuery": true,
          "rawSql": "SELECT name\nFROM grafana_ml_model_feature \nWHERE index=$index2 ",
          "refId": "C",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        }
      ],
      "type": "volkovlabs-echarts-panel"
    }
  ],
  "refresh": "",
  "schemaVersion": 39,
  "tags": [],
  "templating": {
    "list": [
      {
        "current": {},
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
        },
        "definition": "SELECT DISTINCT index\nFROM grafana_ml_model_point_kmeans",
        "description": "Caso para los cuales se desea mostrar las visualizaciones",
        "hide": 0,
        "includeAll": false,
        "label": "Caso particional",
        "multi": false,
        "name": "index",
        "options": [],
        "query": "SELECT DISTINCT index\nFROM grafana_ml_model_point_kmeans",
        "refresh": 1,
        "regex": "",
        "skipUrlSync": false,
        "sort": 0,
        "type": "query"
      },
      {
        "current": {
          "selected": false,
          "text": "KMeans",
          "value": "KMeans"
        },
        "hide": 0,
        "includeAll": false,
        "label": "Tipo particional",
        "multi": false,
        "name": "type",
        "options": [
          {
            "selected": true,
            "text": "KMeans",
            "value": "KMeans"
          },
          {
            "selected": false,
            "text": "KMedoids",
            "value": "KMedoids"
          }
        ],
        "query": "KMeans, KMedoids",
        "queryValue": "",
        "skipUrlSync": false,
        "type": "custom"
      },
      {
        "current": {},
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
        },
        "definition": "SELECT index\nFROM grafana_ml_model_hierarchical_clustering",
        "description": "Caso agrupamiento jerarquico",
        "hide": 0,
        "includeAll": false,
        "label": "Caso jerárquico",
        "multi": false,
        "name": "index2",
        "options": [],
        "query": "SELECT index\nFROM grafana_ml_model_hierarchical_clustering",
        "refresh": 1,
        "regex": "",
        "skipUrlSync": false,
        "sort": 0,
        "type": "query"
      },
      {
        "current": {
          "selected": false,
          "text": "",
          "value": ""
        },
        "description": "El corte del dendograma para separar los clusteres",
        "hide": 0,
        "label": "Corte dendograma",
        "name": "cut",
        "options": [
          {
            "selected": true,
            "text": "",
            "value": ""
          }
        ],
        "query": "",
        "skipUrlSync": false,
        "type": "textbox"
      },
      {
        "current": {
          "selected": false,
          "text": "Paleta 2",
          "value": "Paleta 2"
        },
        "hide": 0,
        "includeAll": false,
        "label": "Color",
        "multi": false,
        "name": "color",
        "options": [
          {
            "selected": false,
            "text": "Paleta 1",
            "value": "Paleta 1"
          },
          {
            "selected": true,
            "text": "Paleta 2",
            "value": "Paleta 2"
          },
          {
            "selected": false,
            "text": "Paleta 3",
            "value": "Paleta 3"
          }
        ],
        "query": "Paleta 1, Paleta 2, Paleta 3",
        "queryValue": "",
        "skipUrlSync": false,
        "type": "custom"
      },
      {
        "current": {
          "selected": false,
          "text": "Círculo",
          "value": "Círculo"
        },
        "hide": 0,
        "includeAll": false,
        "label": "Símbolo",
        "multi": false,
        "name": "shape",
        "options": [
          {
            "selected": true,
            "text": "Círculo",
            "value": "Círculo"
          },
          {
            "selected": false,
            "text": "Triángulo",
            "value": "Triángulo"
          },
          {
            "selected": false,
            "text": "Rectángulo",
            "value": "Rectángulo"
          },
          {
            "selected": false,
            "text": "Pin",
            "value": "Pin"
          }
        ],
        "query": "Círculo, Triángulo, Rectángulo, Pin",
        "queryValue": "",
        "skipUrlSync": false,
        "type": "custom"
      },
      {
        "current": {
          "selected": false,
          "text": "0.5",
          "value": "0.5"
        },
        "hide": 0,
        "includeAll": false,
        "label": "Grozor de las líneas",
        "multi": false,
        "name": "sizeLine",
        "options": [
          {
            "selected": true,
            "text": "0.5",
            "value": "0.5"
          },
          {
            "selected": false,
            "text": "0.6",
            "value": "0.6"
          },
          {
            "selected": false,
            "text": "0.7",
            "value": "0.7"
          },
          {
            "selected": false,
            "text": "0.8",
            "value": "0.8"
          },
          {
            "selected": false,
            "text": "0.9",
            "value": "0.9"
          },
          {
            "selected": false,
            "text": "1",
            "value": "1"
          }
        ],
        "query": "0.5, 0.6, 0.7, 0.8, 0.9, 1",
        "queryValue": "",
        "skipUrlSync": false,
        "type": "custom"
      }
    ]
  },
  "time": {
    "from": "now-6h",
    "to": "now"
  },
  "timepicker": {},
  "timezone": "browser",
  "title": "1-clustering",
  "uid": "ae5xat5tr7474a",
  "version": 482,
  "weekStart": ""
}