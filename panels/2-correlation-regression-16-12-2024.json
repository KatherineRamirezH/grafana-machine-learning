{
  "__inputs": [
    {
      "name": "DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL",
      "label": "grafana-postgresql-datasource-ml-model",
      "description": "",
      "type": "datasource",
      "pluginId": "grafana-postgresql-datasource",
      "pluginName": "PostgreSQL"
    }
  ],
  "__elements": {},
  "__requires": [
    {
      "type": "grafana",
      "id": "grafana",
      "name": "Grafana",
      "version": "11.2.2"
    },
    {
      "type": "datasource",
      "id": "grafana-postgresql-datasource",
      "name": "PostgreSQL",
      "version": "1.0.0"
    },
    {
      "type": "panel",
      "id": "volkovlabs-echarts-panel",
      "name": "Business Charts",
      "version": "6.5.0"
    }
  ],
  "annotations": {
    "list": [
      {
        "builtIn": 1,
        "datasource": {
          "type": "grafana",
          "uid": "-- Grafana --"
        },
        "enable": true,
        "hide": true,
        "iconColor": "rgba(0, 211, 255, 1)",
        "name": "Annotations & Alerts",
        "type": "dashboard"
      }
    ]
  },
  "editable": true,
  "fiscalYearStartMonth": 0,
  "graphTooltip": 0,
  "id": null,
  "links": [],
  "panels": [
    {
      "datasource": {
        "type": "grafana-postgresql-datasource",
        "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
      },
      "description": "",
      "gridPos": {
        "h": 14,
        "w": 12,
        "x": 0,
        "y": 0
      },
      "id": 1,
      "options": {
        "baidu": {
          "callback": "bmapReady",
          "key": ""
        },
        "editor": {
          "format": "auto"
        },
        "editorMode": "code",
        "gaode": {
          "key": "",
          "plugin": "AMap.Scale,AMap.ToolBar"
        },
        "getOption": "if (context.panel.data && context.panel.data.series.length > 0) {\n  const fieldsFeatures = context.panel.data.series[0].fields;\n  const fieldsCorrelations = context.panel.data.series[1].fields;\n\n  let nameFeature = (fieldsFeatures.find(fields => fields.name == 'name')).values;\n  let nameFeatureR = [...nameFeature].reverse();\n  let featureNames1 = (fieldsCorrelations.find(fields => fields.name == 'name_feature1')).values;\n  let featureNames2 = (fieldsCorrelations.find(fields => fields.name == 'name_feature2')).values;\n  let correlation = (fieldsCorrelations.find(fields => fields.name == 'value')).values;\n\n  let correlationList = [];\n\n  // Crear un mapa para asignar índices a los nombres de las características\n  let featureIndexMap = new Map();\n  nameFeature.forEach((name, index) => {\n    featureIndexMap.set(name, index);\n  });\n\n  // Añadir la correlación entre las características iguales\n  for (let i = 0; i < nameFeature.length; i++) {\n    let feature1 = i;\n    let invertedFeature2 = (nameFeature.length - 1) - feature1;\n    correlationList.push([feature1, invertedFeature2, 1]);\n  }\n\n  // Formar lista de correlación\n  for (let i = 0; i < featureNames1.length; i++) {\n    let feature1Name = featureNames1[i];\n    let feature2Name = featureNames2[i];\n\n    // Obtener los índices de las características por su nombre\n    let feature1Index = featureIndexMap.get(feature1Name);\n    let feature2Index = featureIndexMap.get(feature2Name);\n\n    // Correlación para estas características\n    let corr = correlation[i].toFixed(3);\n\n    // Invertir las características para la visualización\n    let invertedFeature2 = (nameFeature.length - 1) - feature2Index;\n    let invertedFeature1 = (nameFeature.length - 1) - feature1Index;\n\n    correlationList.push([feature1Index, invertedFeature2, corr]);\n    correlationList.push([feature2Index, invertedFeature1, corr]);\n  }\n\n  return {\n    title: {\n      text: 'Matriz de correlación',\n      top: \"2%\",\n      left: \"2%\"\n    },\n    tooltip: {\n      position: 'top'\n    },\n    grid: {\n      height: '88%',\n      containLabel: true,\n      left: \"10\",\n      right: \"10%\",\n      top: \"13%\"\n    },\n    xAxis: {\n      type: 'category',\n      data: nameFeature,\n      splitArea: {\n        show: true\n      },\n      axisLabel: {\n        show: true,\n        fontSize: 13,\n        rotate: 26\n      }\n    },\n    yAxis: {\n      type: 'category',\n      data: nameFeatureR,\n      splitArea: {\n        show: true,\n      },\n      axisLabel: {\n        show: true,\n        fontSize: 13,\n        rotate: 0\n      }\n    },\n    visualMap: {\n      min: -1,\n      max: 1,\n      type: 'continuous',\n      calculable: true,\n      orient: 'vertical',\n      left: 'right',\n      left: '91%',\n      bottom: '4%',\n      top: '11%',\n      itemHeight: '400',\n      inRange: {\n        color: getPalete(context.grafana.replaceVariables('${colorsC}'))\n      }\n    },\n    series: [\n      {\n        name: 'Correlación',\n        type: 'heatmap',\n        data: correlationList,\n        label: {\n          show: true\n        },\n        emphasis: {\n          itemStyle: {\n            shadowBlur: 10,\n            shadowColor: 'rgba(0, 0, 0, 0.5)'\n          }\n        }\n      }\n    ]\n  };\n}\n\nfunction getPalete(palete) {\n  let seLectedPaleteValue = ['#00539a', '#fff1f1', '#a2191f'];\n\n  if (palete == 'Paleta 1') {\n    seLectedPaleteValue = ['#00539a', '#fff1f1', '#a2191f'];\n  } else if (palete == 'Paleta 2') {\n    seLectedPaleteValue = ['#005d5d', '#f6f2ff', '#6929c4'];\n  } else if (palete == 'Paleta 3') {\n    seLectedPaleteValue = ['#e5f6ff', '#1192e8', '#003a6d'];\n  }\n\n  return seLectedPaleteValue;\n}\n",
        "google": {
          "callback": "gmapReady",
          "key": ""
        },
        "map": "none",
        "renderer": "canvas",
        "themeEditor": {
          "config": "{}",
          "name": "default"
        },
        "visualEditor": {
          "code": "\n",
          "dataset": [],
          "series": []
        }
      },
      "pluginVersion": "6.5.0",
      "targets": [
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
          },
          "editorMode": "code",
          "format": "table",
          "rawQuery": true,
          "rawSql": "SELECT name\nFROM grafana_ml_model_feature\nWHERE index = $case\nORDER BY id\n",
          "refId": "A",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        },
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
          },
          "editorMode": "code",
          "format": "table",
          "hide": false,
          "rawQuery": true,
          "rawSql": "SELECT \n    f1.name AS name_feature1,\n    f2.name AS name_feature2,\n    g.value\nFROM \n    grafana_ml_model_correlation g\nINNER JOIN \n    grafana_ml_model_feature f1 ON g.id_feature1 = f1.id\nINNER JOIN \n    grafana_ml_model_feature f2 ON g.id_feature2 = f2.id\nWHERE \n    f1.index=$case AND\n    f1.index=$case AND\n    g.index=$case AND\n    g.type='$typeCor';",
          "refId": "B",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        }
      ],
      "type": "volkovlabs-echarts-panel"
    },
    {
      "datasource": {
        "type": "grafana-postgresql-datasource",
        "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
      },
      "description": "",
      "gridPos": {
        "h": 14,
        "w": 12,
        "x": 12,
        "y": 0
      },
      "id": 2,
      "options": {
        "baidu": {
          "callback": "bmapReady",
          "key": ""
        },
        "editor": {
          "format": "auto"
        },
        "editorMode": "code",
        "gaode": {
          "key": "",
          "plugin": "AMap.Scale,AMap.ToolBar"
        },
        "getOption": "if (context.panel.data && context.panel.data.series.length > 0) {\n  const fieldsFeatures = context.panel.data.series[0].fields;\n  const fieldsPoints = context.panel.data.series[2].fields;\n  const fieldsCorrelations = context.panel.data.series[1].fields;\n\n  // Obtener los valores de las características, correlaciones y puntos\n  let featureNames = (fieldsFeatures.find(fields => fields.name == 'name')).values;\n  let pointNames = (fieldsPoints.find(fields => fields.name == 'point_name')).values;\n  let pointValues = (fieldsPoints.find(fields => fields.name == 'feature_values')).values;\n  let featureNames1 = (fieldsCorrelations.find(fields => fields.name == 'name_feature1')).values;\n  let featureNames2 = (fieldsCorrelations.find(fields => fields.name == 'name_feature2')).values;\n  let correlation = (fieldsCorrelations.find(fields => fields.name == 'value')).values;\n\n  // Asignación inicial para las características seleccionadas\n  var selectedFeatureX = featureNames[0];\n  var selectedFeatureY = featureNames[1];\n\n  let parsedValuesPoints = pointValues.map(value => JSON.parse(value));\n\n  // Puntos\n  const pointSeriesData = createSeriesData(parsedValuesPoints, selectedFeatureX, selectedFeatureY);\n\n  // Lógica para la selección\n  if (context.grafana.replaceVariables('${case}') || context.grafana.replaceVariables('${typeCor}')) {\n    let dom = context.panel.chart.getDom();\n    let nodeList = dom.childNodes;\n\n    if (nodeList.length > 2) {\n      nodeList[0].remove();\n    }\n\n    const container = document.createElement(\"div\");\n    container.style.display = \"flex\";\n    container.style.flexDirection = \"row\";\n    container.style.width = \"100%\";\n\n    const leftContainer = document.createElement(\"div\");\n    leftContainer.style.display = \"flex\";\n    leftContainer.style.flexDirection = \"column\";\n    leftContainer.style.flexGrow = \"1\";  \n\n    const title = document.createElement(\"h3\");\n    title.innerHTML = \"Diagrama de dispersión\";\n    title.style.fontWeight = \"bold\";\n    title.style.fontSize = \"18px\";\n    title.style.fontFamily = \"'Arial', sans-serif\";\n    title.style.marginLeft = \"20px\";\n    title.style.marginTop = \"20px\";\n\n    // Label de Correlación\n    const correlationLabel = document.createElement(\"div\");\n    correlationLabel.id = \"correlationLabel\";\n    correlationLabel.style.fontFamily = \"'Arial', sans-serif\";\n    correlationLabel.style.fontWeight = \"normal\";\n    correlationLabel.style.fontSize = \"24px\";  // Tamaño más grande\n    correlationLabel.style.marginTop = \"10px\";  // Reducir el margen superior para que esté más cerca del título\n    correlationLabel.style.textAlign = \"center\";  // Centrar el texto dentro del label\n\n    let correlationValueInitial = getCorrelation(selectedFeatureX, selectedFeatureY);\n    correlationLabel.innerHTML = `Correlación: ${correlationValueInitial.toFixed(3)}`;\n    console.log(correlationValueInitial);\n\n    // Añadir título y correlación al contenedor de la izquierda\n    leftContainer.appendChild(title);\n    leftContainer.appendChild(correlationLabel);\n\n    const rightContainer = document.createElement(\"div\");\n    rightContainer.style.display = \"flex\";\n    rightContainer.style.flexDirection = \"column\";\n    rightContainer.style.alignItems = \"flex-end\";\n    rightContainer.style.marginLeft = \"10px\";\n\n    // Eje X\n    const xAxisContainer = document.createElement(\"div\");\n    xAxisContainer.style.display = \"flex\";\n    xAxisContainer.style.alignItems = \"center\";\n    xAxisContainer.style.marginBottom = \"2px\";\n\n    const xAxisLabel = document.createElement(\"span\");\n    xAxisLabel.innerHTML = \"Eje x:\";\n    xAxisLabel.style.marginRight = \"6px\";\n    xAxisLabel.style.fontFamily = \"'Arial', sans-serif\";\n    xAxisLabel.style.fontWeight = \"bold\";\n    xAxisLabel.style.fontSize = \"14px\";\n    xAxisLabel.style.marginTop = \"20px\";\n\n    const selectListX = document.createElement(\"select\");\n    selectListX.id = \"selectX\";\n    selectListX.style.fontFamily = \"'Arial', sans-serif\";\n    selectListX.style.border = \"1px solid gray\";\n    selectListX.style.borderRadius = \"8px\";\n    selectListX.style.padding = \"5px\";\n    selectListX.style.minWidth = \"120px\";\n    selectListX.style.marginTop = \"20px\";\n    selectListX.style.marginRight = \"10px\";\n\n    // Eje Y\n    const yAxisContainer = document.createElement(\"div\");\n    yAxisContainer.style.display = \"flex\";\n    yAxisContainer.style.alignItems = \"center\";\n    yAxisContainer.style.marginBottom = \"2px\";\n\n    const yAxisLabel = document.createElement(\"span\");\n    yAxisLabel.innerHTML = \"Eje y:\";\n    yAxisLabel.style.marginRight = \"6px\";\n    yAxisLabel.style.fontFamily = \"'Arial', sans-serif\";\n    yAxisLabel.style.fontWeight = \"bold\";\n    yAxisLabel.style.fontSize = \"14px\";\n\n    const selectListY = document.createElement(\"select\");\n    selectListY.id = \"selectY\";\n    selectListY.style.fontFamily = \"'Arial', sans-serif\";\n    selectListY.style.border = \"1px solid gray\";\n    selectListY.style.borderRadius = \"8px\";\n    selectListY.style.padding = \"5px\";\n    selectListY.style.minWidth = \"120px\";\n    selectListY.style.marginRight = \"10px\";\n\n    console.log('hola1');\n\n    featureNames.forEach((value) => {\n      const optionX = document.createElement(\"option\");\n      optionX.value = value; // Aquí usamos el nombre de la característica\n      optionX.text = value;\n      selectListX.appendChild(optionX);\n\n      const optionY = document.createElement(\"option\");\n      optionY.value = value; // Aquí usamos el nombre de la característica\n      optionY.text = value;\n      selectListY.appendChild(optionY);\n    });\n    selectListY.value = selectedFeatureY;\n\n    selectListX.addEventListener(\"change\", () => {\n      selectedFeatureX = selectListX.value; // Actualizamos con el nombre de la característica\n      updateChartData();\n\n      const correlationValue = getCorrelation(selectedFeatureX, selectedFeatureY);\n      correlationLabel.innerHTML = `Correlación: ${correlationValue.toFixed(3)}`;\n    });\n\n    selectListY.addEventListener(\"change\", () => {\n      selectedFeatureY = selectListY.value; // Actualizamos con el nombre de la característica\n      updateChartData();\n\n      const correlationValue = getCorrelation(selectedFeatureX, selectedFeatureY);\n      correlationLabel.innerHTML = `Correlación: ${correlationValue.toFixed(3)}`;\n    });\n\n    // Añadiendo los selectores al rightContainer\n    xAxisContainer.appendChild(xAxisLabel);\n    xAxisContainer.appendChild(selectListX);\n    yAxisContainer.appendChild(yAxisLabel);\n    yAxisContainer.appendChild(selectListY);\n\n    rightContainer.appendChild(xAxisContainer);\n    rightContainer.appendChild(yAxisContainer);\n\n    // Añadiendo el contenido completo al contenedor principal\n    container.appendChild(leftContainer);\n    container.appendChild(rightContainer);\n\n    dom.insertBefore(container, dom.firstChild);\n  }\n\n  // Función para actualizar el gráfico después de un cambio en la selección\n  function updateChartData() {\n    const pointSeriesData = createSeriesData(parsedValuesPoints, selectedFeatureX, selectedFeatureY);\n\n    context.panel.chart.setOption({\n      xAxis: {\n        name: selectedFeatureX, // Usamos el nombre de la característica\n        min: () => calculateMargin(pointValues, featureNames.indexOf(selectedFeatureX))\n      },\n      yAxis: {\n        name: selectedFeatureY, // Usamos el nombre de la característica\n        min: () => calculateMargin(pointValues, featureNames.indexOf(selectedFeatureY))\n      },\n      series: [\n        {\n          name: 'Puntos',\n          data: pointSeriesData,\n          symbolSize: 15,\n          symbol: getShape(context.grafana.replaceVariables('${shape}')),\n          itemStyle: {\n            color: '#888',\n            borderColor: '#555',\n          }\n        }\n      ]\n    });\n  }\n\n  option = {\n    tooltip: {\n      position: 'top',\n      formatter: function (params) {\n        const seriesIndex = params.seriesIndex;\n        const dataIndex = params.dataIndex;\n\n        let featureValues = (seriesIndex === 0 ? parsedValuesPoints : parsedValuesCentroids)[dataIndex];\n        const pointName = (seriesIndex === 0 ? pointNames : centroidNames)[dataIndex];\n\n        return `\n            <div><strong>${pointName}</strong></div>\n            <div>${selectedFeatureX}: ${featureValues[featureNames.indexOf(selectedFeatureX)]}</div>\n            <div>${selectedFeatureY}: ${featureValues[featureNames.indexOf(selectedFeatureY)]}</div>\n          `;\n      }\n    },\n    grid: {\n      bottom: \"25%\",\n      containLabel: true,\n      left: \"30\",\n      right: \"4%\",\n      top: \"3%\"\n    },\n    xAxis: {\n      type: 'value',\n      name: selectedFeatureX,\n      nameLocation: 'middle',\n      nameGap: 20,\n      min: () => calculateMargin(pointValues, featureNames.indexOf(selectedFeatureX))\n    },\n    yAxis: {\n      type: 'value',\n      name: selectedFeatureY,\n      nameLocation: 'middle',\n      nameGap: 30,\n      min: () => calculateMargin(pointValues, featureNames.indexOf(selectedFeatureY))\n    },\n    series: [\n      {\n        name: 'Puntos',\n        type: 'scatter',\n        encode: { tooltip: [0, 1] },\n        symbolSize: context.grafana.replaceVariables('${sizeS}'),\n        symbol: getShape(context.grafana.replaceVariables('${shape}')),\n        itemStyle: {\n          color: '#888',\n          borderColor: '#555',\n        },\n        data: pointSeriesData,\n      }\n    ]\n  };\n\n  return option;\n}\n\n// Función para crear los datos de la serie para el gráfico de dispersión\nfunction createSeriesData(parsedValuesPoints, selectedFeatureX, selectedFeatureY) {\n  const fieldsFeatures = context.panel.data.series[0].fields;\n  let featureNames = (fieldsFeatures.find(fields => fields.name == 'name')).values;\n  let seriesData = [];\n\n  // Obtener el índice correspondiente al nombre de la característica X\n  let xIndex = featureNames.indexOf(selectedFeatureX);\n  let yIndex = featureNames.indexOf(selectedFeatureY);\n\n  // Verificamos si los índices existen (no son -1)\n  if (xIndex === -1 || yIndex === -1) {\n    console.error(`Característica no encontrada. X: ${selectedFeatureX}, Y: ${selectedFeatureY}`);\n    return [];\n  }\n\n  // Obtenemos la correlación entre las características seleccionadas\n  let correlation = getCorrelation(selectedFeatureX, selectedFeatureY);\n\n  parsedValuesPoints.forEach(point => {\n    // Extraemos los valores de las características seleccionadas (X e Y) usando sus índices\n    let xValue = point[xIndex]; // Usamos el índice para obtener el valor de X\n    let yValue = point[yIndex]; // Usamos el índice para obtener el valor de Y\n\n    // Obtenemos el color para la correlación de este punto\n    let color = getColorForCorrelation(correlation);\n\n    // Añadimos el punto de datos con las coordenadas X, Y y el color usando itemStyle\n    seriesData.push({\n      value: [xValue, yValue],  // Las coordenadas del punto\n      itemStyle: {\n        color: color  // Asignamos el color calculado al punto\n      }\n    });\n  });\n\n  return seriesData;\n}\n\n// Función para obtener la correlación entre las características\nfunction getCorrelation(featureX, featureY) {\n  const fieldsCorrelations = context.panel.data.series[1].fields;\n\n  let featureNames1 = fieldsCorrelations.find(fields => fields.name === 'name_feature1');\n  let featureNames2 = fieldsCorrelations.find(fields => fields.name === 'name_feature2');\n  let correlationValues = fieldsCorrelations.find(fields => fields.name === 'value');\n\n  featureNames1 = featureNames1.values;\n  featureNames2 = featureNames2.values;\n  correlationValues = correlationValues.values;\n\n  // Buscar la correlación con los nombres de las características\n  for (let i = 0; i < featureNames1.length; i++) {\n    if ((featureNames1[i] === featureX && featureNames2[i] === featureY) ||\n      (featureNames1[i] === featureY && featureNames2[i] === featureX)) {\n      return correlationValues[i];\n    }\n  }\n\n  // Correlación perfecta consigo misma\n  if (featureX === featureY) {\n    return 1;\n  }\n\n  // Si no se encuentra la correlación\n  return -2;\n}\n\n// Función para obtener el color basado en la correlación\nfunction getColorForCorrelation(correlation) {\n  if (context.grafana.replaceVariables('${colorsC}') == 'Paleta 1') {\n    if (correlation >= 0.8) {\n      return '#a2191f'; // Alta correlación positiva \n    } else if (correlation >= 0.4) {\n      return '#fa4d56'; // Correlación positiva moderada \n    } else if (correlation >= -0.2) {\n      return '#ffd7d9'; // Correlación débil o neutra \n    } else if (correlation >= -0.8) {\n      return '#82cfff'; // Correlación negativa moderada \n    } else {\n      return '#00539a'; // Alta correlación negativa \n    }\n  } else if (context.grafana.replaceVariables('${colorsC}') == 'Paleta 2') {\n    if (correlation >= 0.8) {\n      return '#6929c4'; // Alta correlación positiva \n    } else if (correlation >= 0.4) {\n      return '#a56eff'; // Correlación positiva moderada\n    } else if (correlation >= -0.2) {\n      return '#d9fbfb'; // Correlación débil o neutra \n    } else if (correlation >= -0.8) {\n      return '#009d9a'; // Correlación negativa moderada \n    } else {\n      return '#005d5d'; // Alta correlación negativa \n    }\n  } else if (context.grafana.replaceVariables('${colorsC}') == 'Paleta 3') {\n    if (correlation >= 0.8) {\n      return '#001d6c'; // Alta correlación positiva \n    } else if (correlation >= 0.4) {\n      return '#0043ce'; // Correlación positiva moderada \n    } else if (correlation >= -0.2) {\n      return '#78a9ff'; // Correlación débil o neutra \n    } else if (correlation >= -0.8) {\n      return '#d0e2ff'; // Correlación negativa moderada \n    } else {\n      return '#edf5ff'; // Alta correlación negativa \n    }\n  }\n\n}\n\n// Calcular el margen del 5% basado en el rango de los datos\nfunction calculateMargin(values, axisIndex) {\n  // Asegurarse de que 'values' es un array de objetos JSON para obtener el valor en el índice deseado\n  const axisValues = values.map(value => JSON.parse(value)[axisIndex]);\n\n  // Encontrar el valor mínimo y máximo de los datos\n  const minValue = Math.min(...axisValues);\n  const maxValue = Math.max(...axisValues);\n\n  // Calcular el margen basado en el rango\n  const range = maxValue - minValue;\n  const margin = range * 0.04; // 4% de margen para los ejes\n\n  // Devolver el valor mínimo ajustado con el margen calculado\n  const result = minValue - margin;\n\n  return parseFloat(result.toFixed(1)); // Redondear a un decimal\n}\n\nfunction getShape(shape) {\n  let seLectedShapeValue = 'circle';\n\n  if (shape == 'Círculo') {\n    seLectedShapeValue = 'circle';\n  } else if (shape == 'Triángulo') {\n    seLectedShapeValue = 'triangle';\n  } else if (shape == 'Rectángulo') {\n    seLectedShapeValue = 'rect';\n  } else if (shape == 'Pin') {\n    seLectedShapeValue = 'pin';\n  }\n\n  return seLectedShapeValue;\n}\n",
        "google": {
          "callback": "gmapReady",
          "key": ""
        },
        "map": "none",
        "renderer": "canvas",
        "themeEditor": {
          "config": "{}",
          "name": "default"
        },
        "visualEditor": {
          "code": "",
          "dataset": [],
          "series": []
        }
      },
      "pluginVersion": "6.5.0",
      "targets": [
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
          },
          "editorMode": "code",
          "format": "table",
          "rawQuery": true,
          "rawSql": "SELECT name\nFROM grafana_ml_model_feature\nWHERE index = $case\nORDER BY id\n",
          "refId": "A",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        },
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
          },
          "editorMode": "code",
          "format": "table",
          "hide": false,
          "rawQuery": true,
          "rawSql": "SELECT \n    f1.name AS name_feature1,\n    f2.name AS name_feature2,\n    g.value\nFROM \n    grafana_ml_model_correlation g\nINNER JOIN \n    grafana_ml_model_feature f1 ON g.id_feature1 = f1.id\nINNER JOIN \n    grafana_ml_model_feature f2 ON g.id_feature2 = f2.id\nWHERE \n    g.index = $case AND\n    g.type = '$typeCor';",
          "refId": "B",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        },
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
          },
          "editorMode": "code",
          "format": "table",
          "hide": false,
          "rawQuery": true,
          "rawSql": "SELECT p.name AS point_name, \n       array_to_json(array_agg(pv.value)) AS feature_values\nFROM grafana_ml_model_point p\nJOIN grafana_ml_model_point_value pv \n  ON pv.id_point = p.id\nWHERE p.index = $case AND\n      pv.index=$case \nGROUP BY p.id;",
          "refId": "C",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        }
      ],
      "type": "volkovlabs-echarts-panel"
    },
    {
      "datasource": {
        "type": "grafana-postgresql-datasource",
        "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
      },
      "gridPos": {
        "h": 14,
        "w": 12,
        "x": 0,
        "y": 14
      },
      "id": 6,
      "options": {
        "baidu": {
          "callback": "bmapReady",
          "key": ""
        },
        "editor": {
          "format": "auto"
        },
        "editorMode": "code",
        "gaode": {
          "key": "",
          "plugin": "AMap.Scale,AMap.ToolBar"
        },
        "getOption": "if (context.panel.data && context.panel.data.series.length > 0) {\n  const fieldsFeatures = context.panel.data.series[0].fields;\n  const fieldsCorrelations = context.panel.data.series[1].fields;\n\n  let uniqueNamesFeature = (fieldsFeatures.find(fields => fields.name == 'name')).values;\n  let featureNames1 = (fieldsCorrelations.find(fields => fields.name == 'name_feature1')).values;\n  let featureNames2 = (fieldsCorrelations.find(fields => fields.name == 'name_feature2')).values;\n  let correlation = (fieldsCorrelations.find(fields => fields.name == 'value')).values;\n\n  let selectedFeature = uniqueNamesFeature[0];\n  let data = getCorrelation(selectedFeature);\n\n  // Lógica para la selección\n  if (context.grafana.replaceVariables('${case}') || context.grafana.replaceVariables('${typeCor}')) {\n    let dom = context.panel.chart.getDom();\n    let nodeList = dom.childNodes;\n\n    if (nodeList.length >= 2) {\n      nodeList[0].remove();\n    }\n\n    const container = document.createElement(\"div\");\n    container.style.display = \"flex\";\n    container.style.justifyContent = \"space-between\";\n    container.style.alignItems = \"center\";\n    container.style.marginTop = \"10px\";\n\n    const title = document.createElement(\"h3\");\n    title.innerHTML = \"Correlación entre una característica y las demás.\";\n    title.style.marginLeft = \"20px\";\n    title.style.fontWeight = \"bold\";\n    title.style.fontSize = \"18px\";\n    title.style.fontFamily = \"'Arial', sans-serif\";\n\n    const rightContainer = document.createElement(\"div\");\n    rightContainer.style.display = \"flex\";\n    rightContainer.style.alignItems = \"center\";\n\n    const characteristicLabel = document.createElement(\"span\");\n    characteristicLabel.innerHTML = \"Característica:\";\n    characteristicLabel.style.marginRight = \"6px\";\n    characteristicLabel.style.fontFamily = \"'Arial', sans-serif\";\n    characteristicLabel.style.fontWeight = \"bold\";\n    characteristicLabel.style.fontSize = \"16px\";\n\n    const selectList = document.createElement(\"select\");\n    selectList.id = \"mySelect\";\n    selectList.style.fontFamily = \"'Arial', sans-serif\";\n\n    selectList.style.border = \"1px solid gray\";\n    selectList.style.borderRadius = \"8px\";\n    selectList.style.padding = \"5px\";\n    selectList.style.marginRight = \"10px\";\n\n    uniqueNamesFeature.forEach((value) => {\n      const option = document.createElement(\"option\");\n      option.value = value;\n      option.text = value;\n      selectList.appendChild(option);\n    });\n\n    selectList.addEventListener(\"change\", () => {\n      selectedFeature = selectList.value;\n      let result = getCorrelation(selectedFeature);\n\n      context.panel.chart.setOption({\n        dataset: {\n          source: result\n        },\n        yAxis: {\n          type: 'category'\n        },\n        series: [\n          {\n            type: 'bar',\n            encode: {\n              x: 'Correlación',\n              y: 'Característica'\n            }\n          }\n        ]\n      });\n    });\n\n    rightContainer.appendChild(characteristicLabel);\n    rightContainer.appendChild(selectList);\n\n    container.appendChild(title);\n    container.appendChild(rightContainer);\n\n    dom.insertBefore(container, dom.firstChild);\n  }\n\n  option = {\n    dataset: {\n      source: data\n    },\n    grid: {\n      containLabel: true,\n      top: '4%',\n      left: '1%',\n      right: '12%'\n    },\n    xAxis: {\n\n    },\n    yAxis: {\n      type: 'category'\n    },\n    visualMap: {\n      orient: 'vertical',\n      left: 'right',\n      left: '90%',\n      bottom: '40%',\n      top: '5%',\n      itemHeight: '370',\n      min: -1,\n      max: 1,\n      dimension: 0,\n      inRange: {\n        color: getPalete(context.grafana.replaceVariables('${colorsC}'))\n      },\n      calculable: true\n    },\n    series: [\n      {\n        type: 'bar',\n        encode: {\n          x: 'Correlación',\n          y: 'Característica'\n        }\n      }\n    ]\n  };\n\n  return option;\n}\n\n\nfunction getCorrelation(selectedFeatureName) {\n  const fieldsFeatures = context.panel.data.series[0].fields;\n  const fieldsCorrelations = context.panel.data.series[1].fields;\n\n  let uniqueNamesFeature = (fieldsFeatures.find(fields => fields.name == 'name')).values;\n  let featureNames1 = (fieldsCorrelations.find(fields => fields.name == 'name_feature1')).values;\n  let featureNames2 = (fieldsCorrelations.find(fields => fields.name == 'name_feature2')).values;\n  let correlation = (fieldsCorrelations.find(fields => fields.name == 'value')).values;\n\n  let result = [\n    ['Correlación', 'Característica']\n  ];\n\n  for (let i = 0; i < uniqueNamesFeature.length; i++) {\n    let currentFeature = uniqueNamesFeature[i];\n    let currentCorrelation = 0;\n\n    // Si la característica seleccionada es la misma que la actual, asigna correlación 1\n    if (currentFeature === selectedFeatureName) {\n      currentCorrelation = 1;\n    } else {\n      // Si no es la misma, buscamos la correlación en los arrays featureNames1 y featureNames2\n      for (let j = 0; j < featureNames1.length; j++) {\n        if ((featureNames1[j] === currentFeature && featureNames2[j] === selectedFeatureName) ||\n          (featureNames2[j] === currentFeature && featureNames1[j] === selectedFeatureName)) {\n          currentCorrelation = correlation[j];\n          break;\n        }\n      }\n    }\n\n    result.push([currentCorrelation, currentFeature]);\n  }\n\n  // Ordena el arreglo de correlaciones de menor a mayor (por la primera posición del array)\n  result.sort((a, b) => a[0] - b[0]);\n\n  return result;\n}\n\nfunction getPalete(palete) {\n  let seLectedPaleteValue = ['#00539a', '#fff1f1', '#a2191f'];\n\n  if (palete == 'Paleta 1') {\n    seLectedPaleteValue = ['#00539a', '#fff1f1', '#a2191f'];\n  } else if (palete == 'Paleta 2') {\n    seLectedPaleteValue = ['#005d5d', '#f6f2ff', '#6929c4'];\n  } else if (palete == 'Paleta 3') {\n    seLectedPaleteValue = ['#e5f6ff', '#1192e8', '#003a6d'];\n  }\n\n  return seLectedPaleteValue;\n}",
        "google": {
          "callback": "gmapReady",
          "key": ""
        },
        "map": "none",
        "renderer": "canvas",
        "themeEditor": {
          "config": "{}",
          "name": "default"
        },
        "visualEditor": {
          "code": "",
          "dataset": [],
          "series": []
        }
      },
      "pluginVersion": "6.5.0",
      "targets": [
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
          },
          "editorMode": "code",
          "format": "table",
          "rawQuery": true,
          "rawSql": "SELECT name\nFROM grafana_ml_model_feature\nWHERE index = $case\nORDER BY id\n",
          "refId": "A",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        },
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
          },
          "editorMode": "code",
          "format": "table",
          "hide": false,
          "rawQuery": true,
          "rawSql": "SELECT \n    f1.name AS name_feature1,\n    f2.name AS name_feature2,\n    g.value\nFROM \n    grafana_ml_model_correlation g\nINNER JOIN \n    grafana_ml_model_feature f1 ON g.id_feature1 = f1.id\nINNER JOIN \n    grafana_ml_model_feature f2 ON g.id_feature2 = f2.id\nWHERE \n    g.index = $case AND\n    g.type = '$typeCor';",
          "refId": "B",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        }
      ],
      "type": "volkovlabs-echarts-panel"
    },
    {
      "datasource": {
        "type": "grafana-postgresql-datasource",
        "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
      },
      "gridPos": {
        "h": 14,
        "w": 12,
        "x": 12,
        "y": 14
      },
      "id": 8,
      "options": {
        "baidu": {
          "callback": "bmapReady",
          "key": ""
        },
        "editor": {
          "format": "auto"
        },
        "editorMode": "code",
        "gaode": {
          "key": "",
          "plugin": "AMap.Scale,AMap.ToolBar"
        },
        "getOption": "if (context.panel.data && context.panel.data.series.length > 0) {\n  const fieldsFeatures = context.panel.data.series[0].fields;\n  const fieldsCorrelations = context.panel.data.series[1].fields;\n\n  let uniqueNamesFeature = (fieldsFeatures.find(fields => fields.name == 'name')).values;\n  let featureNames1 = (fieldsCorrelations.find(fields => fields.name == 'name_feature1')).values;\n  let featureNames2 = (fieldsCorrelations.find(fields => fields.name == 'name_feature2')).values;\n  let correlation = (fieldsCorrelations.find(fields => fields.name == 'value')).values;\n\n  // Creamos un objeto de correlaciones que asegura las correlaciones recíprocas\n  let correlationMatrix = {};\n\n  // Inicializamos las correlaciones con 1 para cada característica consigo misma\n  uniqueNamesFeature.forEach(name => {\n    correlationMatrix[name] = {};\n    uniqueNamesFeature.forEach(otherName => {\n      correlationMatrix[name][otherName] = name === otherName ? 1 : null;\n    });\n  });\n\n  // Llenamos la matriz de correlaciones con los valores proporcionados\n  featureNames1.forEach((feature1, index) => {\n    let feature2 = featureNames2[index];\n    let corrValue = correlation[index];\n\n    corrValue = Math.abs(corrValue);\n\n    // Asignamos las correlaciones en ambas direcciones (recíprocas)\n    correlationMatrix[feature1][feature2] = corrValue;\n    correlationMatrix[feature2][feature1] = corrValue;\n  });\n\n  // Creamos la estructura de salida que necesita el formato original\n  let data = uniqueNamesFeature.map(name => {\n    let correlationsForFeature = uniqueNamesFeature.map(otherName => correlationMatrix[name][otherName]);\n    return {\n      name: name,\n      value: correlationsForFeature\n    };\n  });\n\n  let indicator = uniqueNamesFeature.map(name => ({\n    name: name,\n    max: 1\n  }));\n\n  console.log(indicator);\n  option = {\n    grid: {\n      top: '75%',\n    },\n    title: {\n      text: 'Correlación. Diagrama de radar.',\n      top: \"2%\",\n      left: '1%'\n    },\n    legend: {\n      data: uniqueNamesFeature,\n      top: \"2%\",\n      left: \"83%\",\n      orient: 'vertical',\n    },\n    radar: {\n      // shape: 'circle',\n      indicator: indicator\n    },\n    series: [\n      {\n        name: 'Budget vs spending',\n        type: 'radar',\n        data: data,\n      }\n    ]\n  };\n\n  return option;\n}\n\n",
        "google": {
          "callback": "gmapReady",
          "key": ""
        },
        "map": "none",
        "renderer": "canvas",
        "themeEditor": {
          "config": "{}",
          "name": "default"
        },
        "visualEditor": {
          "code": "",
          "dataset": [],
          "series": []
        }
      },
      "pluginVersion": "6.5.0",
      "targets": [
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
          },
          "editorMode": "code",
          "format": "table",
          "rawQuery": true,
          "rawSql": "SELECT name\nFROM grafana_ml_model_feature\nWHERE index = $case\nORDER BY id\n",
          "refId": "A",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        },
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
          },
          "editorMode": "code",
          "format": "table",
          "hide": false,
          "rawQuery": true,
          "rawSql": "SELECT \n    f1.name AS name_feature1,\n    f2.name AS name_feature2,\n    g.value\nFROM \n    grafana_ml_model_correlation g\nINNER JOIN \n    grafana_ml_model_feature f1 ON g.id_feature1 = f1.id\nINNER JOIN \n    grafana_ml_model_feature f2 ON g.id_feature2 = f2.id\nWHERE \n    f1.index=$case AND\n    f1.index=$case AND\n    g.index=$case AND\n    g.type='$typeCor';",
          "refId": "B",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        }
      ],
      "type": "volkovlabs-echarts-panel"
    },
    {
      "datasource": {
        "type": "grafana-postgresql-datasource",
        "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
      },
      "description": "",
      "gridPos": {
        "h": 14,
        "w": 12,
        "x": 0,
        "y": 28
      },
      "id": 3,
      "options": {
        "baidu": {
          "callback": "bmapReady",
          "key": ""
        },
        "editor": {
          "format": "auto"
        },
        "editorMode": "code",
        "gaode": {
          "key": "",
          "plugin": "AMap.Scale,AMap.ToolBar"
        },
        "getOption": "if (context.panel.data && context.panel.data.series.length > 0) {\n  const fields = context.panel.data.series[0].fields;\n\n  let feature = (fields.find(fields => fields.name == 'feature')).values;\n  let coeff = (fields.find(fields => fields.name == 'coeff')).values;\n  let stdErr = (fields.find(fields => fields.name == 'std.err')).values;\n  let tValue = (fields.find(fields => fields.name == 't-value')).values;\n  let p = (fields.find(fields => fields.name == 'P>|t|')).values;\n\n  var categoryData = feature;\n  var errorData = [];\n  var barData = coeff;\n  var dataCount = coeff.length;\n\n  for (let i = 0; i < dataCount; i++) {\n    let coef = coeff[i];\n    let std = stdErr[i];\n\n    let low = coef - std;\n    let high = coef + std;\n    errorData.push([i, low, high]);\n  }\n\n  return {\n    tooltip: {\n      trigger: 'axis',\n      axisPointer: {\n        type: 'shadow'\n      },\n      formatter: function (params) {\n        let index = params[0].dataIndex;\n\n        let name = feature[index];\n        let coef = coeff[index];\n        let std = stdErr[index];\n        let tVal = tValue[index];\n        let pVal = p[index];\n\n        coef = roundToSignificantFigures(coef, 5);\n        std = roundToSignificantFigures(std, 5);\n        tVal = roundToSignificantFigures(tVal, 5);\n        pVal = roundToSignificantFigures(pVal, 5);\n\n        return `\n          <div style=\"text-align: center; text-decoration: underline; font-weight: bold;\">${name}</div>\n          <strong>Coeficiente: </strong>${coef}<br>\n          <strong>Desviación estándar: </strong>${std}<br>\n          <strong>t-value: </strong>${tVal}<br>\n          <strong>P>|t|: </strong>${pVal}<br>\n        `;\n      }\n    },\n    title: {\n      text: 'Coeficientes y desviación estándar',\n      top: \"2%\",\n      left: \"2%\"\n    },\n    legend: {\n      data: ['bar', 'error'],\n      left: '80%',\n      top: \"2%\"\n    },\n    dataZoom: [\n      {\n        type: 'slider',\n        start: 0,\n        end: 100\n      },\n      {\n        type: 'inside',\n        start: 0,\n        end: 100\n      }\n    ],\n    xAxis: {\n      data: categoryData\n    },\n    yAxis: {},\n    series: [\n      {\n        type: 'bar',\n        name: 'bar',\n        data: barData,\n        itemStyle: {\n          color: getColorBar(context.grafana.replaceVariables('${colorsR}')),\n        }\n      },\n      {\n        type: 'custom',\n        name: 'error',\n        itemStyle: {\n          borderWidth: 1.5,\n          color: getColorError(context.grafana.replaceVariables('${colorsR}')),\n        },\n        renderItem: function (params, api) {\n          var xValue = api.value(0);\n          var highPoint = api.coord([xValue, api.value(1)]);\n          var lowPoint = api.coord([xValue, api.value(2)]);\n          var halfWidth = api.size([1, 0])[0] * 0.1;\n          var style = api.style({\n            stroke: api.visual('color'),\n            fill: undefined\n          });\n\n          return {\n            type: 'group',\n            children: [\n              {\n                type: 'line',\n                transition: ['shape'],\n                shape: {\n                  x1: highPoint[0] - halfWidth,\n                  y1: highPoint[1],\n                  x2: highPoint[0] + halfWidth,\n                  y2: highPoint[1]\n                },\n                style: style\n              },\n              {\n                type: 'line',\n                transition: ['shape'],\n                shape: {\n                  x1: highPoint[0],\n                  y1: highPoint[1],\n                  x2: lowPoint[0],\n                  y2: lowPoint[1]\n                },\n                style: style\n              },\n              {\n                type: 'line',\n                transition: ['shape'],\n                shape: {\n                  x1: lowPoint[0] - halfWidth,\n                  y1: lowPoint[1],\n                  x2: lowPoint[0] + halfWidth,\n                  y2: lowPoint[1]\n                },\n                style: style\n              }\n            ]\n          };\n        },\n        encode: {\n          x: 0,\n          y: [1, 2]\n        },\n        data: errorData,\n        z: 100\n      }\n    ]\n  };\n}\n\n// Función para redondear a 5 cifras significativas\nfunction roundToSignificantFigures(num, n) {\n  if (num === 0) return 0;\n  const d = Math.ceil(Math.log10(Math.abs(num)));\n  const power = n - d;\n  const magnitude = Math.pow(10, power);\n  return Math.round(num * magnitude) / magnitude;\n}\n\nfunction getColorBar(color) {\n  let selectedColor = 'blue';\n\n  if (color == 'Azul') {\n    selectedColor = '#77bef7';\n  } else if (color == 'Verde') {\n    selectedColor = '#9EDF9C';\n  } else if (color == 'Naranja') {\n    selectedColor = '#FFB200';\n  } else if (color == 'Amarillo') {\n    selectedColor = '#ffd32c';\n  } else if (color == 'Rosado') {\n    selectedColor = '#FFCCE1';\n  }\n\n  return selectedColor;\n}\n\nfunction getColorError(color) {\n  let selectedColor = 'blue';\n\n  if (color == 'Azul') {\n    selectedColor = '#0043ce';\n  } else if (color == 'Verde') {\n    selectedColor = '#62825D';\n  } else if (color == 'Naranja') {\n    selectedColor = '#EB5B00';\n  } else if (color == 'Amarillo') {\n    selectedColor = '#e0bc00';\n  } else if (color == 'Rosado') {\n    selectedColor = '#E195AB';\n  }\n\n  return selectedColor;\n}",
        "google": {
          "callback": "gmapReady",
          "key": ""
        },
        "map": "none",
        "renderer": "canvas",
        "themeEditor": {
          "config": "{}",
          "name": "default"
        },
        "visualEditor": {
          "code": "\n",
          "dataset": [],
          "series": []
        }
      },
      "pluginVersion": "6.5.0",
      "targets": [
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
          },
          "editorMode": "code",
          "format": "table",
          "rawQuery": true,
          "rawSql": "SELECT \n    f.name AS feature,\n    f.id,\n    r.coeff,\n    r.std_err AS \"std.err\",\n    r.value AS \"t-value\",\n    r.p_value AS \"P>|t|\"\nFROM \n    grafana_ml_model_regression r\nJOIN \n    grafana_ml_model_feature f ON r.id_feature = f.id\nWHERE r.index=$case AND f.index=$case",
          "refId": "A",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        }
      ],
      "type": "volkovlabs-echarts-panel"
    },
    {
      "datasource": {
        "type": "grafana-postgresql-datasource",
        "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
      },
      "description": "",
      "gridPos": {
        "h": 14,
        "w": 12,
        "x": 12,
        "y": 28
      },
      "id": 4,
      "options": {
        "baidu": {
          "callback": "bmapReady",
          "key": ""
        },
        "editor": {
          "format": "auto"
        },
        "editorMode": "code",
        "gaode": {
          "key": "",
          "plugin": "AMap.Scale,AMap.ToolBar"
        },
        "getOption": "if (context.panel.data && context.panel.data.series.length > 0) {\n  const fields = context.panel.data.series[0].fields;\n\n  let feature = (fields.find(fields => fields.name == 'feature')).values;\n  let coeff = (fields.find(fields => fields.name == 'coeff')).values;\n  let stdErr = (fields.find(fields => fields.name == 'std.err')).values;\n  let tValue = (fields.find(fields => fields.name == 't-value')).values;\n  let p = (fields.find(fields => fields.name == 'P>|t|')).values;\n\n  const dimensions = [\n    'Característica', 'Coeficiente', 'Mín', 'Máx',\n    'Desviación estándar', 't-value', 'P>|t|'\n  ];\n\n  let data = [];\n  for (let i = 0; i < feature.length; i++) {\n    let row = [\n      feature[i],\n      parseFloat(coeff[i].toPrecision(4)),\n      parseFloat((coeff[i] - stdErr[i]).toPrecision(4)),\n      parseFloat((coeff[i] + stdErr[i]).toPrecision(4)),\n      parseFloat(stdErr[i].toPrecision(4)),\n      parseFloat(tValue[i].toPrecision(4)),\n      parseFloat(p[i].toPrecision(4))\n    ];\n    data.push(row);\n  }\n\n  function renderItem(params, api) {\n    const group = {\n      type: 'group',\n      children: []\n    };\n\n    let coordDims = ['x', 'y'];\n    for (let baseDimIdx = 0; baseDimIdx < 2; baseDimIdx++) {\n      let otherDimIdx = 1 - baseDimIdx;\n      let encode = params.encode;\n      let baseValue = api.value(encode[coordDims[baseDimIdx]][0]);\n      let param = [];\n      param[baseDimIdx] = baseValue;\n      param[otherDimIdx] = api.value(encode[coordDims[otherDimIdx]][1]);\n      let highPoint = api.coord(param);\n      param[otherDimIdx] = api.value(encode[coordDims[otherDimIdx]][2]);\n      let lowPoint = api.coord(param);\n      let halfWidth = 5;\n      var style = api.style({\n        stroke: api.visual('color'),\n        fill: undefined\n      });\n      group.children.push(\n        {\n          type: 'line',\n          transition: ['shape'],\n          shape: makeShape(\n            baseDimIdx,\n            highPoint[baseDimIdx] - halfWidth,\n            highPoint[otherDimIdx],\n            highPoint[baseDimIdx] + halfWidth,\n            highPoint[otherDimIdx]\n          ),\n          style: style\n        },\n        {\n          type: 'line',\n          transition: ['shape'],\n          shape: makeShape(\n            baseDimIdx,\n            highPoint[baseDimIdx],\n            highPoint[otherDimIdx],\n            lowPoint[baseDimIdx],\n            lowPoint[otherDimIdx]\n          ),\n          style: style\n        },\n        {\n          type: 'line',\n          transition: ['shape'],\n          shape: makeShape(\n            baseDimIdx,\n            lowPoint[baseDimIdx] - halfWidth,\n            lowPoint[otherDimIdx],\n            lowPoint[baseDimIdx] + halfWidth,\n            lowPoint[otherDimIdx]\n          ),\n          style: style\n        }\n      );\n    }\n\n    function makeShape(baseDimIdx, base1, value1, base2, value2) {\n      var shape = {};\n      shape[coordDims[baseDimIdx] + '1'] = base1;\n      shape[coordDims[1 - baseDimIdx] + '1'] = value1;\n      shape[coordDims[baseDimIdx] + '2'] = base2;\n      shape[coordDims[1 - baseDimIdx] + '2'] = value2;\n      return shape;\n    }\n    return group;\n  }\n\n  return {\n    tooltip: {},\n    title: {\n      text: 'Coeficientes y desviación estándar',\n      top: \"2%\",\n      left: \"%\"\n    },\n    dataZoom: [\n      {\n        type: 'slider'\n      },\n      {\n        type: 'inside'\n      }\n    ],\n    grid: {\n      bottom: 80,\n      left: '14%',\n      right: '4%'\n    },\n    xAxis: {\n      type: 'value'\n    },\n    yAxis: {\n      type: 'category',\n      data: feature,\n      nameTextStyle: {\n        align: 'center',\n      },\n      position: 'left',\n      axisLabel: {\n        margin: 10,\n        color: 'black',\n      },\n      axisLine: {\n        show: true,\n        lineStyle: {\n          color: 'red',\n          width: 2,\n        },\n      },\n    },\n    series: [\n      {\n        type: 'scatter',\n        data: data,\n        dimensions: dimensions,\n        symbolSize: context.grafana.replaceVariables('${sizeS}'),\n        encode: {\n          x: 1,\n          y: 0,\n          tooltip: [1, 4, 5, 6],\n          itemName: 0\n        },\n        itemStyle: {\n          color: getColorBar(context.grafana.replaceVariables('${colorsR}')),\n        },\n        symbol: getShape(context.grafana.replaceVariables('${shape}')),\n      },\n      {\n        type: 'custom',\n        name: 'error',\n        renderItem: renderItem,\n        dimensions: dimensions,\n        encode: {\n          x: [1, 2, 3],\n          y: [0],\n          tooltip: [1, 2, 3, 4],\n          itemName: 0\n        },\n        data: data,\n        z: 100,\n        itemStyle: {\n          color: getColorError(context.grafana.replaceVariables('${colorsR}')),\n        }\n      }\n    ]\n  };\n}\n\nfunction getColorBar(color) {\n  let selectedColor = 'blue';\n\n  if (color == 'Azul') {\n    selectedColor = '#77bef7';\n  } else if (color == 'Verde') {\n    selectedColor = '#9EDF9C';\n  } else if (color == 'Naranja') {\n    selectedColor = '#FFB200';\n  } else if (color == 'Amarillo') {\n    selectedColor = '#ffd32c';\n  } else if (color == 'Rosado') {\n    selectedColor = '#FFCCE1';\n  }\n\n  return selectedColor;\n}\n\nfunction getColorError(color) {\n  let selectedColor = 'blue';\n\n  if (color == 'Azul') {\n    selectedColor = '#0043ce';\n  } else if (color == 'Verde') {\n    selectedColor = '#62825D';\n  } else if (color == 'Naranja') {\n    selectedColor = '#EB5B00';\n  } else if (color == 'Amarillo') {\n    selectedColor = '#e0bc00';\n  } else if (color == 'Rosado') {\n    selectedColor = '#E195AB';\n  }\n\n  return selectedColor;\n}\n\nfunction getShape(shape) {\n  let seLectedShapeValue = 'circle';\n\n\n  if (shape == 'Círculo') {\n    seLectedShapeValue = 'circle';\n  } else if (shape == 'Triángulo') {\n    seLectedShapeValue = 'triangle';\n  } else if (shape == 'Rectángulo') {\n    seLectedShapeValue = 'rect';\n  } else if (shape == 'Pin') {\n    seLectedShapeValue = 'pin';\n  }\n\n  return seLectedShapeValue;\n}\n",
        "google": {
          "callback": "gmapReady",
          "key": ""
        },
        "map": "none",
        "renderer": "canvas",
        "themeEditor": {
          "config": "{}",
          "name": "default"
        },
        "visualEditor": {
          "code": "\n",
          "dataset": [],
          "series": []
        }
      },
      "pluginVersion": "6.5.0",
      "targets": [
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
          },
          "editorMode": "code",
          "format": "table",
          "rawQuery": true,
          "rawSql": "SELECT \n    f.name AS feature,\n    r.coeff,\n    r.std_err AS \"std.err\",\n    r.value AS \"t-value\", -- Suponiendo que t-value es el coeficiente dividido por el error estándar\n    r.p_value AS \"P>|t|\"\nFROM \n    grafana_ml_model_regression r\nJOIN \n    grafana_ml_model_feature f ON r.id_feature = f.id\nWHERE r.index=$case AND f.index=$case",
          "refId": "A",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        }
      ],
      "type": "volkovlabs-echarts-panel"
    },
    {
      "datasource": {
        "type": "grafana-postgresql-datasource",
        "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
      },
      "gridPos": {
        "h": 14,
        "w": 12,
        "x": 0,
        "y": 42
      },
      "id": 7,
      "options": {
        "baidu": {
          "callback": "bmapReady",
          "key": ""
        },
        "editor": {
          "format": "auto"
        },
        "editorMode": "visual",
        "gaode": {
          "key": "",
          "plugin": "AMap.Scale,AMap.ToolBar"
        },
        "getOption": "",
        "google": {
          "callback": "gmapReady",
          "key": ""
        },
        "map": "none",
        "renderer": "canvas",
        "themeEditor": {
          "config": "{}",
          "name": "default"
        },
        "visualEditor": {
          "code": "if (context.panel.data && context.panel.data.series.length > 0) {\n  const fieldsValues = context.panel.data.series[0].fields;\n  const fieldsCoeff = context.panel.data.series[1].fields;\n  const fieldsConst = context.panel.data.series[2].fields;\n  const fieldsTarget = context.panel.data.series[3].fields;\n\n  let values = (fieldsValues.find(fields => fields.name == 'feature_values')).values;\n  let coeff = (fieldsCoeff.find(fields => fields.name == 'coefficient')).values;\n  let cconst = (fieldsConst.find(fields => fields.name == 'const')).values[0];\n  let target = (fieldsTarget.find(fields => fields.name == 'target')).values;\n\n  let parsedValues = values.map(value => JSON.parse(value));\n\n  let result = [];\n\n  for (let i = 0; i < values.length; i++) {\n    let features = parsedValues[i];  // Características del punto\n    let realTarget = target[i];  // Valor real de la variable dependiente para este punto\n\n    // Calcular el valor ajustado (X)\n    let adjustedValue = 0;\n    for (let j = 0; j < features.length - 1; j++) {\n      adjustedValue += features[j] * coeff[j];  // Multiplicamos característica por coeficiente\n    }\n\n    adjustedValue += cconst;  // Sumamos la constante\n\n    // Calcular el residuo (Y)\n    let residual = realTarget - adjustedValue;\n\n    // Almacenamos el valor ajustado y el residuo como un array\n    result.push([adjustedValue, residual]);\n  }\n\n  option = {\n    title: {\n      text: 'Residuos vs. valor ajustado',\n      top: \"2%\",\n      left: \"2%\"\n    },\n    grid: {\n      height: '80%',\n      containLabel: true,\n      left: \"25\",\n      right: \"4%\",\n      top: \"15%\"\n    },\n    tooltip: {\n      trigger: 'item',  // El tooltip se dispara cuando se pasa por encima de un punto\n      formatter: function (params) {\n        // Redondear el valor ajustado y el residuo a 4 decimales\n        let adjustedValue = params.data[0].toFixed(4);\n        let residual = params.data[1].toFixed(4);\n\n        return `Valor ajustado: ${adjustedValue}<br>Residuo: ${residual}`;\n      }\n    },\n    xAxis: {\n      name: 'Valor ajustado',\n      nameLocation: 'middle',\n      nameGap: 23,\n    },\n    yAxis: {\n      name: 'Residuos',\n      nameLocation: 'middle',\n      nameGap: 35,\n    },\n    series: [\n      {\n        symbolSize: context.grafana.replaceVariables('${sizeS}'),\n        data: result,\n        symbol: getShape(context.grafana.replaceVariables('${shape}')),\n        type: 'scatter',\n        itemStyle: {\n          color: getColor(context.grafana.replaceVariables('${colorsR}')),\n        }\n      }\n    ]\n  };\n\n  return option;\n}\n\n\nfunction getShape(shape) {\n  let seLectedShapeValue = 'circle';\n\n\n  if (shape == 'Círculo') {\n    seLectedShapeValue = 'circle';\n  } else if (shape == 'Triángulo') {\n    seLectedShapeValue = 'triangle';\n  } else if (shape == 'Rectángulo') {\n    seLectedShapeValue = 'rect';\n  } else if (shape == 'Pin') {\n    seLectedShapeValue = 'pin';\n  }\n\n  return seLectedShapeValue;\n}\n\n\nfunction getColor(color) {\n  let selectedColor = 'blue';\n\n  if (color == 'Azul') {\n    selectedColor = '#77bef7';\n  } else if (color == 'Verde') {\n    selectedColor = '#9EDF9C';\n  } else if (color == 'Naranja') {\n    selectedColor = '#FFB200';\n  } else if (color == 'Amarillo') {\n    selectedColor = '#ffd32c';\n  } else if (color == 'Rosado') {\n    selectedColor = '#FFCCE1';\n  }\n\n  return selectedColor;\n}\n\n\n",
          "dataset": [],
          "series": []
        }
      },
      "pluginVersion": "6.5.0",
      "targets": [
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
          },
          "editorMode": "code",
          "format": "table",
          "rawQuery": true,
          "rawSql": "SELECT \n  p.name AS point_name, \n  array_to_json(array_agg(pv.value ORDER BY pv.id_feature)) AS feature_values\nFROM \"grafana_ml_model_point\" p\nJOIN \"grafana_ml_model_point_value\" pv \n  ON pv.id_point = p.id\nLEFT JOIN \"grafana_ml_model_feature\" f \n  ON f.id = pv.id_feature\nLEFT JOIN \"grafana_ml_model_regression\" r \n  ON r.id_feature = f.id AND r.id_feature IS NULL\nWHERE p.index = $case\n  AND pv.index = $case\n  AND (f.id IS NULL OR r.id_feature IS NULL)  -- Excluir target\nGROUP BY p.id;\n",
          "refId": "A",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        },
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
          },
          "editorMode": "code",
          "format": "table",
          "hide": false,
          "rawQuery": true,
          "rawSql": "SELECT \n    f.name,\n    r.coeff AS coefficient\nFROM \n    grafana_ml_model_regression r\nJOIN \n    grafana_ml_model_feature f \n    ON r.id_feature = f.id\nWHERE \n    r.index = $case \n    AND f.index = $case \n    AND f.id IS NOT NULL\nORDER BY f.id",
          "refId": "B",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        },
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
          },
          "editorMode": "code",
          "format": "table",
          "hide": false,
          "rawQuery": true,
          "rawSql": "SELECT \n    r.coeff AS const\nFROM \n    grafana_ml_model_regression r\nWHERE \n    r.id_feature IS NULL\n    AND r.index = $case;",
          "refId": "C",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        },
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
          },
          "editorMode": "code",
          "format": "table",
          "hide": false,
          "rawQuery": true,
          "rawSql": "SELECT DISTINCT ON (p.id) \n  p.name AS point_name, \n  pv.value AS target\nFROM \"grafana_ml_model_point\" p\nJOIN \"grafana_ml_model_point_value\" pv \n  ON pv.id_point = p.id\nLEFT JOIN \"grafana_ml_model_feature\" f \n  ON f.id = pv.id_feature\nLEFT JOIN \"grafana_ml_model_regression\" r \n  ON r.id_feature = f.id\nWHERE p.index = $case\n  AND pv.index = $case\n  AND r.id_feature IS NULL  \nORDER BY p.id, pv.id_feature; ",
          "refId": "D",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        }
      ],
      "type": "volkovlabs-echarts-panel"
    },
    {
      "datasource": {
        "type": "grafana-postgresql-datasource",
        "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
      },
      "description": "",
      "gridPos": {
        "h": 14,
        "w": 12,
        "x": 12,
        "y": 42
      },
      "id": 5,
      "options": {
        "baidu": {
          "callback": "bmapReady",
          "key": ""
        },
        "editor": {
          "format": "auto"
        },
        "editorMode": "code",
        "gaode": {
          "key": "",
          "plugin": "AMap.Scale,AMap.ToolBar"
        },
        "getOption": "if (context.panel.data && context.panel.data.series.length > 0) {\n  const fieldsPoints = context.panel.data.series[0].fields;\n  const fieldsFeatures = context.panel.data.series[1].fields;\n  const fieldsTarget = context.panel.data.series[2].fields;\n\n  let pointNames = (fieldsPoints.find(fields => fields.name == 'point_name')).values;\n  let pointValues = (fieldsPoints.find(fields => fields.name == 'feature_values')).values;\n  let featuresName = (fieldsFeatures.find(fields => fields.name == 'name')).values;\n  let target = (fieldsTarget.find(fields => fields.name == 'feature')).values[0];\n\n  let parsedValuesPoints = pointValues.map(value => JSON.parse(value));\n\n  let selectedFeature = 0;\n  let posTarget = featuresName.indexOf(target);\n\n  if (context.grafana.replaceVariables('${case}')) {\n    // Lógica para la selección\n    let dom = context.panel.chart.getDom();\n    let nodeList = dom.childNodes;\n\n    if (nodeList.length >= 2) {\n      nodeList[0].remove();\n    }\n\n    const container = document.createElement(\"div\");\n    container.style.display = \"flex\";\n    container.style.justifyContent = \"space-between\";\n    container.style.alignItems = \"center\";\n    container.style.marginTop = \"10px\";\n\n    const title = document.createElement(\"h3\");\n    title.innerHTML = \"Regresión lineal\";\n    title.style.marginLeft = \"20px\";\n    title.style.fontWeight = \"bold\";\n    title.style.fontSize = \"18px\";\n    title.style.fontFamily = \"'Arial', sans-serif\";\n\n    const rightContainer = document.createElement(\"div\");\n    rightContainer.style.display = \"flex\";\n    rightContainer.style.alignItems = \"center\";\n\n    const characteristicLabel = document.createElement(\"span\");\n    characteristicLabel.innerHTML = \"Variable independiente:\";\n    characteristicLabel.style.marginRight = \"6px\";\n    characteristicLabel.style.fontFamily = \"'Arial', sans-serif\";\n    characteristicLabel.style.fontWeight = \"bold\";\n    characteristicLabel.style.fontSize = \"16px\";\n\n    const selectList = document.createElement(\"select\");\n    selectList.id = \"mySelect\";\n    selectList.style.fontFamily = \"'Arial', sans-serif\";\n    selectList.style.border = \"1px solid gray\";\n    selectList.style.borderRadius = \"8px\";\n    selectList.style.padding = \"5px\";\n    selectList.style.marginRight = \"10px\";\n\n    featuresName.forEach((value) => {\n      const option = document.createElement(\"option\");\n      option.value = value;\n      option.text = value;\n      selectList.appendChild(option);\n    });\n\n    selectList.addEventListener(\"change\", () => {\n      let selectedNameFeature = selectList.value;\n      selectedFeature = featuresName.indexOf(selectedNameFeature);\n      let result = createSeriesData(parsedValuesPoints, selectedFeature, posTarget);\n\n      context.panel.chart.setOption({\n        dataset: [\n          {\n            source: result\n          },\n          {\n            transform: {\n              type: 'ecStat:regression',\n            }\n          }\n        ]\n      });\n    });\n\n    rightContainer.appendChild(characteristicLabel);\n    rightContainer.appendChild(selectList);\n\n    container.appendChild(title);\n    container.appendChild(rightContainer);\n\n    dom.insertBefore(container, dom.firstChild);\n\n  }\n\n  const options = {\n    grid: {\n      bottom: \"15%\",\n      containLabel: true,\n      left: \"3%\",\n      right: \"4%\",\n      top: \"10%\",\n    },\n    dataset: [\n      {\n        source: createSeriesData(parsedValuesPoints, selectedFeature, posTarget)\n      },\n      {\n        transform: {\n          type: 'ecStat:regression',\n          // 'linear' by default.\n          // config: { method: 'linear', formulaOn: 'end' }\n        }\n      }\n    ],\n    legend: {\n      left: '5%',\n      top: '2%'\n    },\n    tooltip: {\n      trigger: 'axis',\n      axisPointer: {\n        type: 'cross'\n      }\n    },\n    xAxis: {\n      name: featuresName[selectedFeature],\n      nameLocation: 'middle',\n      nameGap: 23,\n      splitLine: {\n        lineStyle: {\n          type: 'dashed'\n        }\n      }\n    },\n    yAxis: {\n      name: featuresName[posTarget],\n      nameLocation: 'middle',\n      nameGap: 29,\n      splitLine: {\n        lineStyle: {\n          type: 'dashed'\n        }\n      }\n    },\n    series: [\n      {\n        name: 'scatter',\n        type: 'scatter',\n        symbolSize: context.grafana.replaceVariables('${sizeS}'),\n        symbol: getShape(context.grafana.replaceVariables('${shape}')),\n        itemStyle: {\n          color: getColor(context.grafana.replaceVariables('${colorsR}')),\n        }\n      },\n      {\n        name: 'line',\n        type: 'line',\n        datasetIndex: 1,\n        symbolSize: 0.1,\n        symbol: 'circle',\n        label: { show: true, fontSize: 16 },\n        labelLayout: { dx: -20 },\n        itemStyle: {\n          color: getColorLine(context.grafana.replaceVariables('${colorsR}')),\n        },\n        encode: { label: 2, tooltip: 1 }\n      }\n    ]\n  }\n\n\n  import(\"https://esm.sh/echarts-stat@1.2.0\").then(({ default: ecStatImport }) => {\n    context.echarts.registerTransform(ecStatImport.transform.regression);\n    context.panel.chart.setOption(options)\n  });\n\n}\n\n//Array dada 2 dimensiones\nfunction createSeriesData(values, dim1Index, dim2Index) {\n  return values.map((value) => {\n    const dim1 = value[dim1Index];\n    const dim2 = value[dim2Index];\n\n    return [dim1, dim2];\n  });\n}\n\nfunction getShape(shape) {\n  let seLectedShapeValue = 'circle';\n\n\n  if (shape == 'Círculo') {\n    seLectedShapeValue = 'circle';\n  } else if (shape == 'Triángulo') {\n    seLectedShapeValue = 'triangle';\n  } else if (shape == 'Rectángulo') {\n    seLectedShapeValue = 'rect';\n  } else if (shape == 'Pin') {\n    seLectedShapeValue = 'pin';\n  }\n\n  return seLectedShapeValue;\n}\n\nfunction getColor(color) {\n  let selectedColor = 'blue';\n\n  if (color == 'Azul') {\n    selectedColor = '#77bef7';\n  } else if (color == 'Verde') {\n    selectedColor = '#9EDF9C';\n  } else if (color == 'Naranja') {\n    selectedColor = '#FFB200';\n  } else if (color == 'Amarillo') {\n    selectedColor = '#ffd32c';\n  } else if (color == 'Rosado') {\n    selectedColor = '#FFCCE1';\n  }\n\n  return selectedColor;\n}\n\nfunction getColorLine(color) {\n  let selectedColor = 'blue';\n\n  if (color == 'Azul') {\n    selectedColor = '#0043ce';\n  } else if (color == 'Verde') {\n    selectedColor = '#62825D';\n  } else if (color == 'Naranja') {\n    selectedColor = '#EB5B00';\n  } else if (color == 'Amarillo') {\n    selectedColor = '#e0bc00';\n  } else if (color == 'Rosado') {\n    selectedColor = '#E195AB';\n  }\n\n  return selectedColor;\n}",
        "google": {
          "callback": "gmapReady",
          "key": ""
        },
        "map": "none",
        "renderer": "canvas",
        "themeEditor": {
          "config": "{}",
          "name": "default"
        },
        "visualEditor": {
          "code": "\n",
          "dataset": [],
          "series": []
        }
      },
      "pluginVersion": "6.5.0",
      "targets": [
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
          },
          "editorMode": "code",
          "format": "table",
          "rawQuery": true,
          "rawSql": "SELECT \n  p.name AS point_name, \n  array_to_json(array_agg(pv.value ORDER BY pv.id_feature)) AS feature_values\nFROM \"grafana_ml_model_point\" p\nJOIN \"grafana_ml_model_point_value\" pv \n  ON pv.id_point = p.id\nWHERE p.index = $case\n  AND pv.index = $case\nGROUP BY p.id;",
          "refId": "A",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        },
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
          },
          "editorMode": "code",
          "format": "table",
          "hide": false,
          "rawQuery": true,
          "rawSql": "SELECT name\nFROM grafana_ml_model_feature\nWHERE index = $case \nORDER BY id\n",
          "refId": "B",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        },
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
          },
          "editorMode": "code",
          "format": "table",
          "hide": false,
          "rawQuery": true,
          "rawSql": "SELECT \n    f.name AS feature\nFROM \n    grafana_ml_model_feature f\nLEFT JOIN \n    grafana_ml_model_regression r ON r.id_feature = f.id \nWHERE \n    f.index = $case     \n    AND f.index=$case\n    AND r.id_feature IS NULL",
          "refId": "C",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        }
      ],
      "type": "volkovlabs-echarts-panel"
    }
  ],
  "refresh": "",
  "schemaVersion": 39,
  "tags": [],
  "templating": {
    "list": [
      {
        "current": {},
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
        },
        "definition": "SELECT index\nFROM grafana_ml_model_correlation",
        "description": "",
        "hide": 0,
        "includeAll": false,
        "label": "Caso",
        "multi": false,
        "name": "case",
        "options": [],
        "query": "SELECT index\nFROM grafana_ml_model_correlation",
        "refresh": 1,
        "regex": "",
        "skipUrlSync": false,
        "sort": 0,
        "type": "query"
      },
      {
        "current": {},
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
        },
        "definition": "SELECT DISTINCT type\nFROM grafana_ml_model_correlation;",
        "hide": 0,
        "includeAll": false,
        "label": "Tipo correlación",
        "multi": false,
        "name": "typeCor",
        "options": [],
        "query": "SELECT DISTINCT type\nFROM grafana_ml_model_correlation;",
        "refresh": 1,
        "regex": "",
        "skipUrlSync": false,
        "sort": 0,
        "type": "query"
      },
      {
        "current": {},
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "${DS_GRAFANA-POSTGRESQL-DATASOURCE-ML-MODEL}"
        },
        "definition": "SELECT DISTINCT type\nFROM grafana_ml_model_regression",
        "hide": 0,
        "includeAll": false,
        "label": "Tipo de regresión",
        "multi": false,
        "name": "typeReg",
        "options": [],
        "query": "SELECT DISTINCT type\nFROM grafana_ml_model_regression",
        "refresh": 1,
        "regex": "",
        "skipUrlSync": false,
        "sort": 0,
        "type": "query"
      },
      {
        "current": {
          "selected": false,
          "text": "Paleta 1",
          "value": "Paleta 1"
        },
        "hide": 0,
        "includeAll": false,
        "label": "Color correlación ",
        "multi": false,
        "name": "colorsC",
        "options": [
          {
            "selected": true,
            "text": "Paleta 1",
            "value": "Paleta 1"
          },
          {
            "selected": false,
            "text": "Paleta 2",
            "value": "Paleta 2"
          },
          {
            "selected": false,
            "text": "Paleta 3",
            "value": "Paleta 3"
          }
        ],
        "query": "Paleta 1, Paleta 2, Paleta 3",
        "queryValue": "",
        "skipUrlSync": false,
        "type": "custom"
      },
      {
        "current": {
          "selected": false,
          "text": "Azul",
          "value": "Azul"
        },
        "hide": 0,
        "includeAll": false,
        "label": "Color regresión",
        "multi": false,
        "name": "colorsR",
        "options": [
          {
            "selected": true,
            "text": "Azul",
            "value": "Azul"
          },
          {
            "selected": false,
            "text": "Verde",
            "value": "Verde"
          },
          {
            "selected": false,
            "text": "Naranja",
            "value": "Naranja"
          },
          {
            "selected": false,
            "text": "Amarillo",
            "value": "Amarillo"
          },
          {
            "selected": false,
            "text": "Rosado",
            "value": "Rosado"
          }
        ],
        "query": "Azul, Verde, Naranja, Amarillo, Rosado",
        "queryValue": "",
        "skipUrlSync": false,
        "type": "custom"
      },
      {
        "current": {
          "selected": false,
          "text": "Círculo",
          "value": "Círculo"
        },
        "hide": 0,
        "includeAll": false,
        "label": "Símbolo",
        "multi": false,
        "name": "shape",
        "options": [
          {
            "selected": true,
            "text": "Círculo",
            "value": "Círculo"
          },
          {
            "selected": false,
            "text": "Triángulo",
            "value": "Triángulo"
          },
          {
            "selected": false,
            "text": "Rectángulo",
            "value": "Rectángulo"
          },
          {
            "selected": false,
            "text": "Pin",
            "value": "Pin"
          }
        ],
        "query": "Círculo, Triángulo, Rectángulo, Pin",
        "queryValue": "",
        "skipUrlSync": false,
        "type": "custom"
      },
      {
        "current": {
          "selected": false,
          "text": "10",
          "value": "10"
        },
        "hide": 0,
        "includeAll": false,
        "label": "Tamaño símbolo",
        "multi": false,
        "name": "sizeS",
        "options": [
          {
            "selected": true,
            "text": "10",
            "value": "10"
          },
          {
            "selected": false,
            "text": "11",
            "value": "11"
          },
          {
            "selected": false,
            "text": "12",
            "value": "12"
          },
          {
            "selected": false,
            "text": "13",
            "value": "13"
          },
          {
            "selected": false,
            "text": "14",
            "value": "14"
          },
          {
            "selected": false,
            "text": "15",
            "value": "15"
          },
          {
            "selected": false,
            "text": "16",
            "value": "16"
          }
        ],
        "query": "10, 11, 12, 13, 14, 15, 16",
        "queryValue": "",
        "skipUrlSync": false,
        "type": "custom"
      }
    ]
  },
  "time": {
    "from": "now-6h",
    "to": "now"
  },
  "timepicker": {},
  "timezone": "browser",
  "title": "2-correlation-regression",
  "uid": "ce5x9ukdpr8cgd",
  "version": 50,
  "weekStart": ""
}